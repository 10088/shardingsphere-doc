commit 70aaacb7dc3a0ded455e43a7eda60f6ee2038cec
Author: Mike0601 <40025573+Mike0601@users.noreply.github.com>
Date:   Wed Jul 27 15:17:04 2022 +0800

    Update feature sharding (#19597)
    
    * Refactor document
    
    Remove concepts document
    
    * refactor
    
    * update feature sharding

diff --git a/docs/document/content/features/sharding/_index.cn.md b/docs/document/content/features/sharding/_index.cn.md
index 60be0de674b..01949c2b5e1 100644
--- a/docs/document/content/features/sharding/_index.cn.md
+++ b/docs/document/content/features/sharding/_index.cn.md
@@ -5,29 +5,11 @@ weight = 4
 chapter = true
 +++
 
-## 背景
+## 定义
 
-传统的将数据集中存储至单一节点的解决方案，在性能、可用性和运维成本这三方面已经难于满足海量数据的场景。
+数据分片指按照某个维度将存放在单一数据库中的数据分散地存放至多个数据库或表中以达到提升性能瓶颈以及可用性的效果。 数据分片的有效手段是对关系型数据库进行分库和分表。分库和分表均可以有效的避免由数据量超过可承受阈值而产生的查询瓶颈。 除此之外，分库还能够用于有效的分散对数据库单点的访问量；分表虽然无法缓解数据库压力，但却能够提供尽量将分布式事务转化为本地事务的可能，一旦涉及到跨库的更新操作，分布式事务往往会使问题变得复杂。 使用多主多从的分片方式，可以有效的避免数据单点，从而提升数据架构的可用性。
 
-从性能方面来说，由于关系型数据库大多采用 B+ 树类型的索引，在数据量超过阈值的情况下，索引深度的增加也将使得磁盘访问的 IO 次数增加，进而导致查询性能的下降；
-同时，高并发访问请求也使得集中式数据库成为系统的最大瓶颈。
-
-从可用性的方面来讲，服务化的无状态性，能够达到较小成本的随意扩容，这必然导致系统的最终压力都落在数据库之上。
-而单一的数据节点，或者简单的主从架构，已经越来越难以承担。数据库的可用性，已成为整个系统的关键。
-
-从运维成本方面考虑，当一个数据库实例中的数据达到阈值以上，对于 DBA 的运维压力就会增大。
-数据备份和恢复的时间成本都将随着数据量的大小而愈发不可控。一般来讲，单一数据库实例的数据的阈值在 1TB 之内，是比较合理的范围。
-
-在传统的关系型数据库无法满足互联网场景需要的情况下，将数据存储至原生支持分布式的 NoSQL 的尝试越来越多。
-但 NoSQL 对 SQL 的不兼容性以及生态圈的不完善，使得它们在与关系型数据库的博弈中始终无法完成致命一击，而关系型数据库的地位却依然不可撼动。
-
-数据分片指按照某个维度将存放在单一数据库中的数据分散地存放至多个数据库或表中以达到提升性能瓶颈以及可用性的效果。
-数据分片的有效手段是对关系型数据库进行分库和分表。分库和分表均可以有效的避免由数据量超过可承受阈值而产生的查询瓶颈。
-除此之外，分库还能够用于有效的分散对数据库单点的访问量；分表虽然无法缓解数据库压力，但却能够提供尽量将分布式事务转化为本地事务的可能，一旦涉及到跨库的更新操作，分布式事务往往会使问题变得复杂。
-使用多主多从的分片方式，可以有效的避免数据单点，从而提升数据架构的可用性。
-
-通过分库和分表进行数据的拆分来使得各个表的数据量保持在阈值以下，以及对流量进行疏导应对高访问量，是应对高并发和海量数据系统的有效手段。
-数据分片的拆分方式又分为垂直分片和水平分片。
+通过分库和分表进行数据的拆分来使得各个表的数据量保持在阈值以下，以及对流量进行疏导应对高访问量，是应对高并发和海量数据系统的有效手段。 数据分片的拆分方式又分为垂直分片和水平分片。
 
 ### 垂直分片
 
@@ -50,23 +32,338 @@ chapter = true
 
 水平分片从理论上突破了单机数据量处理的瓶颈，并且扩展相对自由，是数据分片的标准解决方案。
 
-## 挑战
+## 相关概念
+
+### 表
+
+表是透明化数据分片的关键概念。 Apache ShardingSphere 通过提供多样化的表类型，适配不同场景下的数据分片需求。
+
+#### 逻辑表
+
+相同结构的水平拆分数据库（表）的逻辑名称，是 SQL 中表的逻辑标识。 例：订单数据根据主键尾数拆分为 10 张表，分别是 `t_order_0` 到 `t_order_9`，他们的逻辑表名为 `t_order`。
+
+#### 真实表
+
+在水平拆分的数据库中真实存在的物理表。 即上个示例中的 `t_order_0` 到 `t_order_9`。
+
+#### 绑定表
+
+指分片规则一致的一组分片表。 使用绑定表进行多表关联查询时，必须使用分片键进行关联，否则会出现笛卡尔积关联或跨库关联，从而影响查询效率。 例如：`t_order` 表和 `t_order_item` 表，均按照 `order_id` 分片，并且使用 `order_id` 进行关联，则此两张表互为绑定表关系。 绑定表之间的多表关联查询不会出现笛卡尔积关联，关联查询效率将大大提升。 举例说明，如果 SQL 为：
+
+```sql
+SELECT i.* FROM t_order o JOIN t_order_item i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);
+```
+
+在不配置绑定表关系时，假设分片键 order_id 将数值 10 路由至第 0 片，将数值 11 路由至第 1 片，那么路由后的 SQL 应该为 4 条，它们呈现为笛卡尔积：
+
+```sql
+SELECT i.* FROM t_order_0 o JOIN t_order_item_0 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);
+
+SELECT i.* FROM t_order_0 o JOIN t_order_item_1 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);
+
+SELECT i.* FROM t_order_1 o JOIN t_order_item_0 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);
+
+SELECT i.* FROM t_order_1 o JOIN t_order_item_1 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);
+```
+
+在配置绑定表关系，并且使用 `order_id` 进行关联后，路由的 SQL 应该为 2 条：
+
+```sql
+SELECT i.* FROM t_order_0 o JOIN t_order_item_0 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);
+
+SELECT i.* FROM t_order_1 o JOIN t_order_item_1 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);
+```
+
+其中 `t_order` 表由于指定了分片条件，ShardingSphere 将会以它作为整个绑定表的主表。 所有路由计算将会只使用主表的策略，那么 `t_order_item` 表的分片计算将会使用 `t_order` 的条件。
+
+#### 广播表
+
+指所有的分片数据源中都存在的表，表结构及其数据在每个数据库中均完全一致。 适用于数据量不大且需要与海量数据的表进行关联查询的场景，例如：字典表。
+
+#### 单表
+
+指所有的分片数据源中仅唯一存在的表。 适用于数据量不大且无需分片的表。
+
+### 数据节点
+
+数据分片的最小单元，由数据源名称和真实表组成。 例：ds_0.t_order_0。
+逻辑表与真实表的映射关系，可分为均匀分布和自定义分布两种形式。
+
+#### 均匀分布
+
+指数据表在每个数据源内呈现均匀分布的态势， 例如：
+
+```Nginx
+db0
+  ├── t_order0
+  └── t_order1
+db1
+  ├── t_order0
+  └── t_order1
+```
+
+数据节点的配置如下：
+
+```CSS
+db0.t_order0, db0.t_order1, db1.t_order0, db1.t_order1
+```
+
+#### 自定义分布
+
+指数据表呈现有特定规则的分布， 例如：
+
+```Nginx
+db0
+  ├── t_order0
+  └── t_order1
+db1
+  ├── t_order2
+  ├── t_order3
+  └── t_order4
+```
+
+数据节点的配置如下：
+
+```CSS
+db0.t_order0, db0.t_order1, db1.t_order2, db1.t_order3, db1.t_order4
+```
+
+### 分片
+
+#### 分片键
+
+用于将数据库（表）水平拆分的数据库字段。 例：将订单表中的订单主键的尾数取模分片，则订单主键为分片字段。 SQL 中如果无分片字段，将执行全路由，性能较差。 除了对单分片字段的支持，Apache ShardingSphere 也支持根据多个字段进行分片。
+
+#### 分片算法
+
+用于将数据分片的算法，支持 `=`、`>=`、`<=`、`>`、`<`、`BETWEEN` 和 `IN` 进行分片。 分片算法可由开发者自行实现，也可使用 Apache ShardingSphere 内置的分片算法语法糖，灵活度非常高。
+
+#### 自动化分片算法
+
+分片算法语法糖，用于便捷的托管所有数据节点，使用者无需关注真实表的物理分布。 包括取模、哈希、范围、时间等常用分片算法的实现。
+
+#### 自定义分片算法
+
+提供接口让应用开发者自行实现与业务实现紧密相关的分片算法，并允许使用者自行管理真实表的物理分布。 自定义分片算法又分为：
+
+- 标准分片算法
+
+用于处理使用单一键作为分片键的 `=`、`IN`、`BETWEEN AND`、`>`、`<`、`>=`、`<=` 进行分片的场景。
+
+- 复合分片算法
+
+用于处理使用多键作为分片键进行分片的场景，包含多个分片键的逻辑较复杂，需要应用开发者自行处理其中的复杂度。
+
+- Hint 分片算法
+
+用于处理使用 `Hint` 行分片的场景。
+
+#### 分片策略
+
+包含分片键和分片算法，由于分片算法的独立性，将其独立抽离。 真正可用于分片操作的是分片键 + 分片算法，也就是分片策略。
+
+#### 强制分片路由
+
+对于分片字段并非由 SQL 而是其他外置条件决定的场景，可使用 SQL Hint 注入分片值。 例：按照员工登录主键分库，而数据库中并无此字段。 SQL Hint 支持通过 Java API 和 SQL 注释两种方式使用。 详情请参见强制分片路由。
+
+### 行表达式
+
+行表达式是为了解决配置的简化与一体化这两个主要问题。在繁琐的数据分片规则配置中，随着数据节点的增多，大量的重复配置使得配置本身不易被维护。 通过行表达式可以有效地简化数据节点配置工作量。
+
+对于常见的分片算法，使用 Java 代码实现并不有助于配置的统一管理。 通过行表达式书写分片算法，可以有效地将规则配置一同存放，更加易于浏览与存储。
+
+行表达式的使用非常直观，只需要在配置中使用 `${ expression }` 或 `$->{ expression }` 标识行表达式即可。 目前支持数据节点和分片算法这两个部分的配置。 行表达式的内容使用的是 Groovy 的语法，Groovy 能够支持的所有操作，行表达式均能够支持。 例如：
+
+`${begin..end}` 表示范围区间
+`${[unit1, unit2, unit_x]}` 表示枚举值
+
+行表达式中如果出现连续多个 `${ expression }` 或 `$->{ expression }` 表达式，整个表达式最终的结果将会根据每个子表达式的结果进行笛卡尔组合。
+
+例如，以下行表达式：
+
+```Groovy
+${['online', 'offline']}_table${1..3}
+```
+
+最终会解析为：
+```PlainText
+online_table1, online_table2, online_table3, offline_table1, offline_table2, offline_table3
+```
+
+### 分布式主键
+
+传统数据库软件开发中，主键自动生成技术是基本需求。而各个数据库对于该需求也提供了相应的支持，比如 MySQL 的自增键，Oracle 的自增序列等。 数据分片后，不同数据节点生成全局唯一主键是非常棘手的问题。同一个逻辑表内的不同实际表之间的自增键由于无法互相感知而产生重复主键。 虽然可通过约束自增主键初始值和步长的方式避免碰撞，但需引入额外的运维规则，使解决方案缺乏完整性和可扩展性。
+
+目前有许多第三方解决方案可以完美解决这个问题，如 UUID 等依靠特定算法自生成不重复键，或者通过引入主键生成服务等。为了方便用户使用、满足不同用户不同使用场景的需求， Apache ShardingSphere 不仅提供了内置的分布式主键生成器，例如 UUID、SNOWFLAKE，还抽离出分布式主键生成器的接口，方便用户自行实现自定义的自增主键生成器。
+
+## 对系统的影响
 
 虽然数据分片解决了性能、可用性以及单点备份恢复等问题，但分布式的架构在获得了收益的同时，也引入了新的问题。
 
-面对如此散乱的分片之后的数据，应用开发工程师和数据库管理员对数据库的操作变得异常繁重就是其中的重要挑战之一。
-他们需要知道数据需要从哪个具体的数据库的子表中获取。
+面对如此散乱的分片之后的数据，应用开发工程师和数据库管理员对数据库的操作变得异常繁重就是其中的重要挑战之一。 他们需要知道数据需要从哪个具体的数据库的子表中获取。
+
+另一个挑战则是，能够正确的运行在单节点数据库中的 SQL，在分片之后的数据库中并不一定能够正确运行。 例如，分表导致表名称的修改，或者分页、排序、聚合分组等操作的不正确处理。
+
+跨库事务也是分布式的数据库集群要面对的棘手事情。 合理采用分表，可以在降低单表数据量的情况下，尽量使用本地事务，善于使用同库不同表可有效避免分布式事务带来的麻烦。 在不能避免跨库事务的场景，有些业务仍然需要保持事务的一致性。 而基于 XA 的分布式事务由于在并发度高的场景中性能无法满足需要，并未被互联网巨头大规模使用，他们大多采用最终一致性的柔性事务代替强一致事务。
+
+## 使用限制
+
+兼容全部常用的路由至单数据节点的 SQL； 路由至多数据节点的 SQL 由于场景复杂，分为稳定支持、实验性支持和不支持这三种情况。
+
+### 稳定支持
+
+全面支持 DML、DDL、DCL、TCL 和常用 DAL。 支持分页、去重、排序、分组、聚合、表关联等复杂查询。 支持 PostgreSQL 和 openGauss 数据库 SCHEMA DDL 和 DML 语句。
+
+#### 常规查询
+
+- SELECT 主语句
+
+```sql
+SELECT select_expr [, select_expr ...] FROM table_reference [, table_reference ...]
+[WHERE predicates]
+[GROUP BY {col_name | position} [ASC | DESC], ...]
+[ORDER BY {col_name | position} [ASC | DESC], ...]
+[LIMIT {[offset,] row_count | row_count OFFSET offset}]
+```
+
+- select_expr
+
+```sql
+* | 
+[DISTINCT] COLUMN_NAME [AS] [alias] | 
+(MAX | MIN | SUM | AVG)(COLUMN_NAME | alias) [AS] [alias] | 
+COUNT(* | COLUMN_NAME | alias) [AS] [alias]
+```
+
+- table_reference
+
+```sql
+tbl_name [AS] alias] [index_hint_list]
+| table_reference ([INNER] | {LEFT|RIGHT} [OUTER]) JOIN table_factor [JOIN ON conditional_expr | USING (column_list)]
+```
+
+#### 子查询
+
+子查询和外层查询同时指定分片键，且分片键的值保持一致时，由内核提供稳定支持。
+
+例如：
+
+```sql
+SELECT * FROM (SELECT * FROM t_order WHERE order_id = 1) o WHERE o.order_id = 1;
+```
+
+用于[分页](https://shardingsphere.apache.org/document/current/cn/features/sharding/use-norms/pagination)的子查询，由内核提供稳定支持。
+
+例如：
+
+```sql
+SELECT * FROM (SELECT row_.*, rownum rownum_ FROM (SELECT * FROM t_order) row_ WHERE rownum <= ?) WHERE rownum > ?;
+```
+
+#### 分页查询
+
+完全支持 MySQL、PostgreSQL、openGauss，Oracle 和 SQLServer 由于分页查询较为复杂，仅部分支持。
+
+Oracle 和 SQLServer 的分页都需要通过子查询来处理，ShardingSphere 支持分页相关的子查询。
+
+- Oracle
+
+支持使用 rownum 进行分页：
+
+```sql
+SELECT * FROM (SELECT row_.*, rownum rownum_ FROM (SELECT o.order_id as order_id FROM t_order o JOIN t_order_item i ON o.order_id = i.order_id) row_ WHERE rownum <= ?) WHERE rownum > ?
+```
+
+- SQLServer
+
+支持使用 TOP + ROW_NUMBER() OVER 配合进行分页：
+
+```sql
+SELECT * FROM (SELECT TOP (?) ROW_NUMBER() OVER (ORDER BY o.order_id DESC) AS rownum, * FROM t_order o) AS temp WHERE temp.rownum > ? ORDER BY temp.order_id
+```
+支持 SQLServer 2012 之后的 OFFSET FETCH 的分页方式：
+
+```sql
+SELECT * FROM t_order o ORDER BY id OFFSET ? ROW FETCH NEXT ? ROWS ONLY
+```
+
+- MySQL, PostgreSQL 和 openGauss
+
+MySQL、PostgreSQL 和 openGauss 都支持 LIMIT 分页，无需子查询：
+
+```sql
+SELECT * FROM t_order o ORDER BY id LIMIT ? OFFSET ?
+```
+
+#### 运算表达式中包含分片键
+
+当分片键处于运算表达式中时，无法通过 SQL `字面` 提取用于分片的值，将导致全路由。
+例如，假设 `create_time` 为分片键：
+
+```sql
+SELECT * FROM t_order WHERE to_date(create_time, 'yyyy-mm-dd') = '2019-01-01';
+```
+
+### 实验性支持
+
+实验性支持特指使用 Federation 执行引擎提供支持。 该引擎处于快速开发中，用户虽基本可用，但仍需大量优化，是实验性产品。
+
+#### 子查询
+
+子查询和外层查询未同时指定分片键，或分片键的值不一致时，由 Federation 执行引擎提供支持。
+
+例如：
+
+```sql
+SELECT * FROM (SELECT * FROM t_order) o;
+
+SELECT * FROM (SELECT * FROM t_order) o WHERE o.order_id = 1;
+
+SELECT * FROM (SELECT * FROM t_order WHERE order_id = 1) o;
+
+SELECT * FROM (SELECT * FROM t_order WHERE order_id = 1) o WHERE o.order_id = 2;
+```
+
+#### 跨库关联查询
+
+当关联查询中的多个表分布在不同的数据库实例上时，由 Federation 执行引擎提供支持。 假设 `t_order` 和 `t_order_item` 是多数据节点的分片表，并且未配置绑定表规则，`t_user` 和 `t_user_role` 是分布在不同的数据库实例上的单表，那么 Federation 执行引擎能够支持如下常用的关联查询：
+
+```sql
+SELECT * FROM t_order o INNER JOIN t_order_item i ON o.order_id = i.order_id WHERE o.order_id = 1;
+
+SELECT * FROM t_order o INNER JOIN t_user u ON o.user_id = u.user_id WHERE o.user_id = 1;
+
+SELECT * FROM t_order o LEFT JOIN t_user_role r ON o.user_id = r.user_id WHERE o.user_id = 1;
+
+SELECT * FROM t_order_item i LEFT JOIN t_user u ON i.user_id = u.user_id WHERE i.user_id = 1;
+
+SELECT * FROM t_order_item i RIGHT JOIN t_user_role r ON i.user_id = r.user_id WHERE i.user_id = 1;
+
+SELECT * FROM t_user u RIGHT JOIN t_user_role r ON u.user_id = r.user_id WHERE u.user_id = 1;
+```
+
+### 不支持
+
+#### CASE WHEN
+以下 CASE WHEN 语句不支持：
+
+- CASE WHEN 中包含子查询
+- CASE WHEN 中使用逻辑表名（请使用表别名）
+
+#### 分页查询
+
+Oracle 和 SQLServer 由于分页查询较为复杂，目前有部分分页查询不支持，具体如下：
+
+- Oracle
 
-另一个挑战则是，能够正确的运行在单节点数据库中的 SQL，在分片之后的数据库中并不一定能够正确运行。
-例如，分表导致表名称的修改，或者分页、排序、聚合分组等操作的不正确处理。
+目前不支持 rownum + BETWEEN 的分页方式。
 
-跨库事务也是分布式的数据库集群要面对的棘手事情。
-合理采用分表，可以在降低单表数据量的情况下，尽量使用本地事务，善于使用同库不同表可有效避免分布式事务带来的麻烦。
-在不能避免跨库事务的场景，有些业务仍然需要保持事务的一致性。
-而基于 XA 的分布式事务由于在并发度高的场景中性能无法满足需要，并未被互联网巨头大规模使用，他们大多采用最终一致性的柔性事务代替强一致事务。
+- SQLServer
 
-## 目标
+目前不支持使用 WITH xxx AS (SELECT …) 的方式进行分页。由于 Hibernate 自动生成的 SQLServer 分页语句使用了 WITH 语句，因此目前并不支持基于 Hibernate 的 SQLServer 分页。 目前也不支持使用两个 TOP + 子查询的方式实现分页。
 
-**尽量透明化分库分表所带来的影响，让使用方尽量像使用一个数据库一样使用水平分片之后的数据库集群，是 Apache ShardingSphere 数据分片模块的主要设计目标。**
+## 相关参考
 
-**源码：https://github.com/apache/shardingsphere/tree/master/shardingsphere-features/shardingsphere-sharding**
+- [数据分片的配置](/cn/user-manual/shardingsphere-jdbc/yaml-config/rules/sharding/)
+- [数据分片的开发者指南](/cn/dev-manual/sharding/)
+- 源码：https://github.com/apache/shardingsphere/tree/master/shardingsphere-features/shardingsphere-sharding
diff --git a/docs/document/content/features/sharding/_index.en.md b/docs/document/content/features/sharding/_index.en.md
index 9d9451f2607..3dd0ec77797 100644
--- a/docs/document/content/features/sharding/_index.en.md
+++ b/docs/document/content/features/sharding/_index.en.md
@@ -5,22 +5,15 @@ weight = 4
 chapter = true
 +++
 
-## Background
+## Definition
 
-The traditional solution that stores all the data in one concentrated node has hardly satisfied the requirement of massive data scenario in three aspects, performance, availability and operation cost.
+Data sharding refers to distributing the data stored in a single database to be stored in multiple databases or tables on a certain dimension to improve and extend limits of performance and improve availability. 
 
-In performance, the relational database mostly uses B+ tree index. When the data amount exceeds the threshold, deeper index will increase the disk IO access number, and thereby, weaken the performance of query. In the same time, high concurrency requests also make the centralized database to be the greatest limitation of the system.
+An effective way of data fragmentation is to splitting the relational database into libraries and tables. Both database and table splitting can effectively avoid query bottlenecks caused by data flow exceeding the determined threshold. 
 
-In availability, capacity can be expanded at a relatively low cost and any extent with stateless service, which can make all the pressure, at last, fall on the database. But the single data node or simple primary-replica structure has been harder and harder to take these pressures. Therefore, database availability has become the key to the whole system.
+Library splitting can also be used to effectively distribute access to a single point of the database. Although table splitting cannot relieve the pressure on the database, it can convert distributed transactions into local transactions as much as possible, which often compounds the problem once cross-library update operations are involved. The use of multi-primary multi-secondary sharding can effectively avoid too much pressure on a single data point, improving the availability of data architecture.
 
-From the aspect of operation costs, when the data in a database instance has reached above the threshold, DBA’s operation pressure will also increase. The time cost of data backup and data recovery will be more uncontrollable with increasing amount of data. Generally, it is a relatively reasonable range for the data in single database case to be within 1TB.
-
-Under the circumstance that traditional relational databases cannot satisfy the requirement of the Internet, there are more and more attempts to store the data in native distributed NoSQL. But its incompatibility with SQL and imperfection in ecosystem block it from defeating the relational database in the competition, so the relational database still holds an unshakable position.
-
-Sharding refers to splitting the data in one database and storing them in multiple tables and databases according to some certain standard, so that the performance and availability can be improved. Both methods can effectively avoid the query limitation caused by data exceeding affordable threshold. What’s more, database sharding can also effectively disperse TPS. Table sharding, though cannot ease the database pressure, can provide possibilities to transfer distributed transactions to local transactions, since cross-database upgrades are once involved, distributed transactions can turn pretty tricky sometimes. The use of multiple primary-replica sharding method can effectively avoid the data concentrating on one node and increase the architecture availability.
-
-Splitting data through database sharding and table sharding is an effective method to deal with high TPS and mass amount data system, because it can keep the data amount lower than the threshold and evacuate the traffic. 
-Sharding method can be divided into vertical sharding and horizontal sharding.
+By library and table data sharding, the data volume of each table can be kept below the threshold and traffic can be channeled to cope with high access volume, which is an effective means to cope with high concurrency and massive data. The data sharding method consists of vertical sharding and horizontal sharding.
 
 ### Vertical Sharding
 
@@ -38,19 +31,332 @@ Horizontal sharding is also called transverse sharding. Compared with the catego
 
 Theoretically, horizontal sharding has overcome the limitation of data processing volume in single machine and can be extended relatively freely, so it can be taken as a standard solution to database sharding and table sharding.
 
-## Challenges
+## Related Concepts
+
+### Table
+
+Tables are a key concept for transparent data sharding. Apache ShardingSphere adapts to the data sharding requirements under different scenarios by providing diverse table types.
+
+#### Logic Table
+
+The logical name of the horizontally sharded database (table) of the same structure is the logical identifier of the table in SQL. Example: Order data is split into 10 tables according to the primary key endings, are `t_order_0` to `t_order_9`, and their logical table names are `t_order`.
+
+#### Actual Table
+
+Physical tables that exist in the horizontally sharded databases. Those are, `t_order_0` to `t_order_9` in the previous example.
+
+
+#### Binding Table
+
+Refers to a set of sharded tables with consistent sharding rules. When using binding tables for multi-table associated query, a sharding key must be used for the association, otherwise, Cartesian product association or cross-library association will occur, affecting query efficiency. 
+
+For example, if the `t_order` table and `t_order_item` table are both sharded according to `order_id` and are correlated using `order_id`, the two tables are binding tables. The multi-table associated queries between binding tables will not have a Cartesian product association, so the associated queries will be much more effective. Here is an example,
+
+If SQL is:
+
+```sql
+SELECT i.* FROM t_order o JOIN t_order_item i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);
+```
+
+In the case where no binding table relationships are being set, assume that the sharding key `order_id` routes the value 10 to slice 0 and the value 11 to slice 1, then the routed SQL should be 4 items, which are presented as a Cartesian product:
+
+```sql
+SELECT i.* FROM t_order_0 o JOIN t_order_item_0 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);
+
+SELECT i.* FROM t_order_0 o JOIN t_order_item_1 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);
+
+SELECT i.* FROM t_order_1 o JOIN t_order_item_0 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);
+
+SELECT i.* FROM t_order_1 o JOIN t_order_item_1 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);
+```
+
+After the relationships between binding tables are configured and associated with order_id, the routed SQL should then be 2 items:
+
+```sql
+SELECT i.* FROM t_order_0 o JOIN t_order_item_0 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);
+
+SELECT i.* FROM t_order_1 o JOIN t_order_item_1 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);
+```
+
+The t_order table will be used by ShardingSphere as the master table for the entire binding table since it specifies the sharding condition. All routing calculations will use only the policy of the primary table, then the sharding calculations for the `t_order_item` table will use the `t_order` condition.
+
+#### Broadcast data frame
+
+Refers to tables that exist in all sharded data sources. The table structure and its data are identical in each database. Suitable for scenarios where the data volume is small and queries are required to be associated with tables of massive data, e.g., dictionary tables.
+
+#### Single Table
+
+Refers to the only table that exists in all sharded data sources. Suitable for tables with a small amount of data and do not need to be sharded.
+
+### Data Nodes
+
+The smallest unit of the data shard, consists of the data source name and the real table. Example: `ds_0.t_order_0`.
+
+The mapping relationship between the logical table and the real table can be classified into two forms: uniform distribution and custom distribution.
+
+#### Uniform Distribution
+
+refers to situations where the data table exhibits a uniform distribution within each data source. For example:
+
+```Nginx
+db0
+  ├── t_order0
+  └── t_order1
+db1
+  ├── t_order0
+  └── t_order1
+```
+
+The configuration of data nodes:
+
+```CSS
+db0.t_order0, db0.t_order1, db1.t_order0, db1.t_order1
+```
+
+#### Customized Distribution
+
+Data table exhibiting a patterned distribution. For example:
+
+```Nginx
+db0
+  ├── t_order0
+  └── t_order1
+db1
+  ├── t_order2
+  ├── t_order3
+  └── t_order4
+```
+
+configuration of data nodes:
+
+```CSS
+db0.t_order0, db0.t_order1, db1.t_order2, db1.t_order3, db1.t_order4
+```
+
+### Sharding
+
+#### Sharding key
+
+A database field is used to split a database (table) horizontally. Example: If the order primary key in the order table is sharded by modulo, the order primary key is a sharded field. If there is no sharded field in SQL, full routing will be executed, of which performance is poor. In addition to the support for single-sharding fields, Apache ShardingSphere also supports sharding based on multiple fields.
+
+#### Sharding Algorithm
+
+Algorithm for sharding data, supporting `=`, `>=`, `<=`, `>`, `<`, `BETWEEN` and `IN`. The sharding algorithm can be implemented by the developers themselves or can use the Apache ShardingSphere built-in sharding algorithm, syntax sugar, which is very flexible.
+
+#### Automatic Sharding Algorithm
+
+Sharding algorithm—syntactic sugar is for conveniently hosting all data nodes without users having to concern themselves with the physical distribution of actual tables. Includes implementations of common sharding algorithms such as modulo, hash, range, and time.	
+
+#### Customized Sharding Algorithm
+
+Provides a portal for application developers to implement their sharding algorithms that are closely related to their business operations, while allowing users to manage the physical distribution of actual tables themselves. Customized sharding algorithms are further divided into:
+- Standard Sharding Algorithm
+Used to deal with scenarios where sharding is performed using a single key as the sharding key `=`, `IN`, `BETWEEN AND`, `>`, `<`, `>=`, `<=`.
+- Composite Sharding Algorithm
+Used to cope with scenarios where multiple keys are used as sharding keys. The logic containing multiple sharding keys is very complicated and requires the application developers to handle it on their own.
+- Hint Sharding Algorithm 
+For scenarios involving Hint sharding.
+
+#### Sharding Strategy
+
+Consisting of a sharding key and sharding algorithm, which is abstracted independently due to the independence of the sharding algorithm. What is viable for sharding operations is the sharding key + sharding algorithm, known as sharding strategy.
+
+#### Mandatory Sharding routing
+
+For the scenario where the sharded field is not determined by SQL but by other external conditions, you can use SQL Hint to inject the shard value. Example: Conduct database sharding by employee login primary key, but there is no such field in the database. SQL Hint can be used both via Java API and SQL annotation. See Mandatory Sharding Routing for details.
+
+#### Row Value Expressions
+
+Row expressions are designed to address the two main issues of configuration simplification and integration. In the cumbersome configuration rules of data sharding, the large number of repetitive configurations makes the configuration itself difficult to maintain as the number of data nodes increases. The data node configuration workload can be effectively simplified by row expressions.
+
+For the common sharding algorithm, using Java code implementation does not help to manage the configuration uniformly. But by writing the sharding algorithm through line expressions, the rule configuration can be effectively stored together, which is easier to browse and store.
+
+Row expressions are very intuitive, just use `${ expression }` or `$->{ expression }` in the configuration to identify the row expressions. Data nodes and sharding algorithms are currently supported. The content of row expressions uses Groovy syntax, and all operations supported by Groovy are supported by row expressions. For example:
+
+`${begin..end}` denotes the range interval
+
+`${[unit1, unit2, unit_x]}` denotes the enumeration value
+
+If there are multiple `${ expression }` or `$->{ expression }` expressions in a row expression, the final result of the whole expression will be a Cartesian combination based on the result of each sub-expression.
+
+e.g. The following row expression:
+
+```Groovy
+${['online', 'offline']}_table${1..3}
+```
+
+Finally, it can be parsed as this:
+
+```PlainText
+online_table1, online_table2, online_table3, offline_table1, offline_table2, offline_table3
+```
+
+#### Distributed Primary Key
+
+In traditional database software development, automatic primary key generation is a basic requirement. Various databases provide support for this requirement, such as self-incrementing keys of MySQL, self-incrementing sequences of Oracle, etc. After data sharding, it is very tricky to generate global unique primary keys for different data nodes. Self-incrementing keys between different actual tables within the same logical table generate repetitive primary keys because they are not mutually aware. Although collisions can be avoided by constraining the initial value and step size of self-incrementing primary keys, additional operational and maintenance rules are necessary to be introduced, rendering the solution lacking in completeness and scalability.
+
+Many third-party solutions can perfectly solve this problem, such as UUID, which relies on specific algorithms to self-generate non-repeating keys, or by introducing primary key generation services. To facilitate users and meet their demands for different scenarios, Apache ShardingSphere not only provides built-in distributed primary key generators, such as UUID and SNOWFLAKE but also abstracts the interface of distributed primary key generators to enable users to implement their own customized self-extending primary key generators.
+
+## Impact on the system
+
+Although data sharding solves problems regarding performance, availability, and backup recovery of single points, the distributed architecture has introduced new problems while gaining benefits.
+
+One of the major challenges is that application development engineers and database administrators become extremely overwhelmed with all these operations after such a scattered way of data sharding. They need to know from which specific sub-table can they fetch the data needed.
+
+Another challenge is that SQL that works correctly in one single-node database does not necessarily work correctly in a sharded database. For example, table splitting results in table name changes, or incorrect handling of operations such as paging, sorting, and aggregate grouping.
+
+Cross-library transactions are also tricky for a distributed database cluster. Reasonable use of table splitting can minimize the use of local transactions while reducing the amount of data in a single table, and appropriate use of different tables in the same database can effectively avoid the trouble caused by distributed transactions. In scenarios where cross-library transactions cannot be avoided, some businesses might still be in the need to maintain transaction consistency. The XA-based distributed transactions are not used by Internet giants on a large scale because their performance cannot meet the needs in scenarios with high concurrency, and most of them use flexible transactions with ultimate consistency instead of strong consistent transactions.
+
+## Limitations
+
+Compatible with all commonly used SQL that routes to single data nodes; SQL routing to multiple data nodes is divided, because of complexity issues, into three conditions: stable support, experimental support, and no support.
+
+### Stable Support
+
+Full support for DML, DDL, DCL, TCL, and common DALs. Support for complex queries such as paging, de-duplication, sorting, grouping, aggregation, table association, etc. Support SCHEMA DDL and DML statements of PostgreSQL and openGauss database.
+
+#### Normal Queries
+
+- main statement SELECT
+
+```sql
+SELECT select_expr [, select_expr ...] FROM table_reference [, table_reference ...]
+[WHERE predicates]
+[GROUP BY {col_name | position} [ASC | DESC], ...]
+[ORDER BY {col_name | position} [ASC | DESC], ...]
+[LIMIT {[offset,] row_count | row_count OFFSET offset}]
+```
+
+- select_expr
+
+```sql
+* | 
+[DISTINCT] COLUMN_NAME [AS] [alias] | 
+(MAX | MIN | SUM | AVG)(COLUMN_NAME | alias) [AS] [alias] | 
+COUNT(* | COLUMN_NAME | alias) [AS] [alias]
+```
+
+- table_reference
+
+```sql
+tbl_name [AS] alias] [index_hint_list]
+| table_reference ([INNER] | {LEFT|RIGHT} [OUTER]) JOIN table_factor [JOIN ON conditional_expr | USING (column_list)]
+```
+
+#### Sub-query
+
+Stable support is provided by the kernel when both the subquery and the outer query specify a shard key and the values of the slice key remain consistent.
+e.g:
+
+```sql
+SELECT * FROM (SELECT * FROM t_order WHERE order_id = 1) o WHERE o.order_id = 1;
+```
+Sub-query for [pagination](https://shardingsphere.apache.org/document/current/cn/features/sharding/use-norms/pagination/) can be stably supported by the kernel.
+e.g.:
+
+```sql
+SELECT * FROM (SELECT row_.*, rownum rownum_ FROM (SELECT * FROM t_order) row_ WHERE rownum <= ?) WHERE rownum > ?;
+```
+
+#### Pagination Query
+
+MySQL, PostgreSQL, and openGauss are fully supported, Oracle and SQLServer are only partially supported due to more intricate paging queries.
+
+Pagination for Oracle and SQLServer needs to be handled by subqueries, and ShardingSphere supports paging-related subqueries.
+
+- Oracle
+Support pagination by rownum
+
+```sql
+SELECT * FROM (SELECT row_.*, rownum rownum_ FROM (SELECT o.order_id as order_id FROM t_order o JOIN t_order_item i ON o.order_id = i.order_id) row_ WHERE rownum <= ?) WHERE rownum > ?
+```
+
+- SQL Server
+Support pagination that coordinates TOP + ROW_NUMBER() OVER
+
+```sql
+SELECT * FROM (SELECT TOP (?) ROW_NUMBER() OVER (ORDER BY o.order_id DESC) AS rownum, * FROM t_order o) AS temp WHERE temp.rownum > ? ORDER BY temp.order_id
+```
+
+Support pagination by OFFSET FETCH after SQLServer 2012
+
+```sql
+SELECT * FROM t_order o ORDER BY id OFFSET ? ROW FETCH NEXT ? ROWS ONLY
+```
+
+- MySQL, PostgreSQL and openGauss all support  LIMIT pagination without the need for sub-query：
+
+```sql
+SELECT * FROM t_order o ORDER BY id LIMIT ? OFFSET ?
+```
+
+#### Shard keys included in operation expressions
+
+When the sharding key is contained in an expression, the value used for sharding cannot be extracted through the SQL letters and will result in full routing.
+
+For example, assume `create_time` is a sharding key.
+
+```sql
+SELECT * FROM t_order WHERE to_date(create_time, 'yyyy-mm-dd') = '2019-01-01';
+```
+
+### Experimental Support 
+
+Experimental support refers specifically to support provided by implementing Federation execution engine, an experimental product that is still under development. Although largely available to users, it still requires significant optimization.
+
+#### Sub-query
+
+The Federation execution engine provides support for subqueries and outer queries that do not both specify a sharding key or have inconsistent values for the sharding key.
+
+e.g:
+
+```sql
+SELECT * FROM (SELECT * FROM t_order) o;
+
+SELECT * FROM (SELECT * FROM t_order) o WHERE o.order_id = 1;
+
+SELECT * FROM (SELECT * FROM t_order WHERE order_id = 1) o;
+
+SELECT * FROM (SELECT * FROM t_order WHERE order_id = 1) o WHERE o.order_id = 2;
+```
+
+#### Cross-database Associated query
+
+When multiple tables in an associated query are distributed across different database instances, the Federation execution engine can provide support. Assuming that t_order and t_order_item are sharded tables with multiple data nodes while no binding table rules are configured, and t_user and t_user_role are single tables distributed across different database instances, then the Federation execution engine can support the following common associated queries.
+
+```sql
+SELECT * FROM t_order o INNER JOIN t_order_item i ON o.order_id = i.order_id WHERE o.order_id = 1;
+
+SELECT * FROM t_order o INNER JOIN t_user u ON o.user_id = u.user_id WHERE o.user_id = 1;
+
+SELECT * FROM t_order o LEFT JOIN t_user_role r ON o.user_id = r.user_id WHERE o.user_id = 1;
+
+SELECT * FROM t_order_item i LEFT JOIN t_user u ON i.user_id = u.user_id WHERE i.user_id = 1;
+
+SELECT * FROM t_order_item i RIGHT JOIN t_user_role r ON i.user_id = r.user_id WHERE i.user_id = 1;
+
+SELECT * FROM t_user u RIGHT JOIN t_user_role r ON u.user_id = r.user_id WHERE u.user_id = 1;
+```
+
+### Do not Support
 
-Though sharding has solved problems such as performance, availability and single-node backup and recovery, its distributed architecture has also introduced some new problems as acquiring profits.
+#### CASE WHEN
 
-One problem is that application development engineers and database administrators’ operations become exceptionally laborious, when facing such scattered databases and tables. They should know exactly which database table is the one to acquire data from.
+The following CASE WHEN statements are not supported:
+- `CASE WHEN` contains sub-query
+- Logic names are used in `CASE WHEN`( Please use an alias)
 
-Another challenge is that, the SQL that runs rightly in single-node databases may not be right in the sharding database. The change of table name after sharding, or misconducts caused by operations such as pagination, order by or aggregated group by are just the case in point.
+#### Pagination Query
 
-Cross-database transaction is also a tricky thing that distributed databases need to deal. Fair use of sharding tables can also lead to the full use of local transactions when single-table data amount decreases. 
-Troubles brought by distributed transactions can be avoided by the wise use of different tables in the same database. When cross-database transactions cannot be avoided, some businesses still need to keep transactions consistent. Internet giants have not massively adopted XA based distributed transactions since they are not able to ensure its performance in high-concurrency situations. They usually replace strongly consistent transactions with eventually consistent soft state.
+Due to the complexity of paging queries, there are currently some paging queries that are not supported for Oracle and SQLServer, such as:
+- Oracle
+The paging method of rownum + BETWEEN is not supported at present
 
-## Goal
+- SQLServer
+Currently, pagination with WITH xxx AS (SELECT ...) is not supported. Since the SQLServer paging statement automatically generated by Hibernate uses the WITH statement, Hibernate-based SQLServer paging is not supported at this moment. Pagination using two TOP + subquery also cannot be supported at this time.
 
-**The main design goal of the data sharding modular of Apache ShardingSphere is to try to reduce the influence of sharding, in order to let users use horizontal sharding database group like one database.**
+## Related References
 
-**Source Codes: https://github.com/apache/shardingsphere/tree/master/shardingsphere-features/shardingsphere-sharding**
+- User Guide: [sharding](https://shardingsphere.apache.org/document/current/en/user-manual/shardingsphere-jdbc/yaml-config/rules/sharding/)
+- Developer Guide: [sharding](https://shardingsphere.apache.org/document/current/en/dev-manual/sharding/)
+- Source Codes: https://github.com/apache/shardingsphere/tree/master/shardingsphere-features/shardingsphere-sharding
diff --git a/docs/document/content/features/sharding/concept/_index.cn.md b/docs/document/content/features/sharding/concept/_index.cn.md
deleted file mode 100644
index eb53f028f87..00000000000
--- a/docs/document/content/features/sharding/concept/_index.cn.md
+++ /dev/null
@@ -1,9 +0,0 @@
-+++
-title = "核心概念"
-weight = 1
-chapter = true
-+++
-
-## 导览
-
-本小节主要介绍数据分片的核心概念。
diff --git a/docs/document/content/features/sharding/concept/_index.en.md b/docs/document/content/features/sharding/concept/_index.en.md
deleted file mode 100644
index 3b07b49f5b1..00000000000
--- a/docs/document/content/features/sharding/concept/_index.en.md
+++ /dev/null
@@ -1,9 +0,0 @@
-+++
-title = "Core Concept"
-weight = 1
-chapter = true
-+++
-
-## Overview
-
-This chapter is to introduce core concepts of data sharding.
diff --git a/docs/document/content/features/sharding/concept/datanode.cn.md b/docs/document/content/features/sharding/concept/datanode.cn.md
deleted file mode 100644
index 30daaab337d..00000000000
--- a/docs/document/content/features/sharding/concept/datanode.cn.md
+++ /dev/null
@@ -1,50 +0,0 @@
-+++
-title = "数据节点"
-weight = 2
-+++
-
-数据分片的最小单元，由数据源名称和真实表组成。
-例：`ds_0.t_order_0`。
-
-逻辑表与真实表的映射关系，可分为均匀分布和自定义分布两种形式。
-
-## 均匀分布
-
-指数据表在每个数据源内呈现均匀分布的态势，
-例如：
-
-```
-db0
-  ├── t_order0
-  └── t_order1
-db1
-  ├── t_order0
-  └── t_order1
-```
-
-数据节点的配置如下：
-
-```
-db0.t_order0, db0.t_order1, db1.t_order0, db1.t_order1
-```
-
-## 自定义分布
-
-指数据表呈现有特定规则的分布，
-例如：
-
-```
-db0
-  ├── t_order0
-  └── t_order1
-db1
-  ├── t_order2
-  ├── t_order3
-  └── t_order4
-```
-
-数据节点的配置如下：
-
-```
-db0.t_order0, db0.t_order1, db1.t_order2, db1.t_order3, db1.t_order4
-```
diff --git a/docs/document/content/features/sharding/concept/datanode.en.md b/docs/document/content/features/sharding/concept/datanode.en.md
deleted file mode 100644
index 5675d2a2a08..00000000000
--- a/docs/document/content/features/sharding/concept/datanode.en.md
+++ /dev/null
@@ -1,47 +0,0 @@
-+++
-title = "Data Node"
-weight = 2
-+++
-
-As the atomic unit of sharding, it consists of data source name and actual table name, e.g. `ds_0.t_order_0`.
-
-Mapping relationship between logic tables and actual tables and can be divided into two kinds: uniform topology and user-defined topology.
-
-## Uniform topology
-
-It means that tables are evenly distributed in each data source, for example: 
-
-```
-db0
-  ├── t_order0
-  └── t_order1
-db1
-  ├── t_order0
-  └── t_order1
-```
-
-The data node configurations will be as follows:
-
-```
-db0.t_order0, db0.t_order1, db1.t_order0, db1.t_order1
-```
-
-## User-defined topology
-
-It means that tables are distributed with certain rules, for example:
-
-```
-db0
-  ├── t_order0 
-  └── t_order1 
-db1
-  ├── t_order2
-  ├── t_order3
-  └── t_order4
-```
-
-The data node configurations will be as follows:
-
-```
-db0.t_order0, db0.t_order1, db1.t_order2, db1.t_order3, db1.t_order4
-```
diff --git a/docs/document/content/features/sharding/concept/hint.cn.md b/docs/document/content/features/sharding/concept/hint.cn.md
deleted file mode 100644
index b776c390871..00000000000
--- a/docs/document/content/features/sharding/concept/hint.cn.md
+++ /dev/null
@@ -1,21 +0,0 @@
-+++
-title = "强制分片路由"
-weight = 6
-+++
-
-## 实现动机
-
-通过解析 SQL 语句提取分片键列与值并进行分片是 Apache ShardingSphere 对 SQL 零侵入的实现方式。
-若 SQL 语句中没有分片条件，则无法进行分片，需要全路由。
-
-在一些应用场景中，分片条件并不存在于 SQL，而存在于外部业务逻辑。
-因此需要提供一种通过外部指定分片结果的方式，在 Apache ShardingSphere 中叫做 Hint。
-
-## 实现机制
-
-Apache ShardingSphere 使用 `ThreadLocal` 管理分片键值。
-可以通过编程的方式向 `HintManager` 中添加分片条件，该分片条件仅在当前线程内生效。
-
-除了通过编程的方式使用强制分片路由，Apache ShardingSphere 还可以通过 SQL 中的特殊注释的方式引用 Hint，使开发者可以采用更加透明的方式使用该功能。
-
-指定了强制分片路由的 SQL 将会无视原有的分片逻辑，直接路由至指定的真实数据节点。
diff --git a/docs/document/content/features/sharding/concept/hint.en.md b/docs/document/content/features/sharding/concept/hint.en.md
deleted file mode 100644
index 653ed0df303..00000000000
--- a/docs/document/content/features/sharding/concept/hint.en.md
+++ /dev/null
@@ -1,21 +0,0 @@
-+++
-title = "Hint Sharding Route"
-weight = 6
-+++
-
-## Motivation
-
-Apache ShardingSphere can be compatible with SQL in way of parsing SQL statements and extracting columns and values to shard. 
-If SQL does not have sharding conditions, it is impossible to shard without full data node route.
-
-In some applications, sharding conditions are not in SQL but in external business logic. 
-So it requires to designate sharding result externally, which is referred to as `Hint` in ShardingSphere.
-
-## Mechanism
-
-Apache ShardingSphere uses `ThreadLocal` to manage sharding key values. 
-Users can program to add sharding conditions to `HintManager`, but the condition is only effective within the current thread.
-
-In addition to the programming method, Apache ShardingSphere is able to cite Hint through special notation in SQL, so that users can use that function in a more transparent way.
-
-The SQL designated with sharding hint will ignore the former sharding logic but directly route to the designated node.
diff --git a/docs/document/content/features/sharding/concept/inline-expression.cn.md b/docs/document/content/features/sharding/concept/inline-expression.cn.md
deleted file mode 100644
index b9f8436a894..00000000000
--- a/docs/document/content/features/sharding/concept/inline-expression.cn.md
+++ /dev/null
@@ -1,170 +0,0 @@
-+++
-title = "行表达式"
-weight = 4
-+++
-
-## 实现动机
-
-配置的简化与一体化是行表达式所希望解决的两个主要问题。
-
-在繁琐的数据分片规则配置中，随着数据节点的增多，大量的重复配置使得配置本身不易被维护。
-通过行表达式可以有效地简化数据节点配置工作量。
-
-对于常见的分片算法，使用 Java 代码实现并不有助于配置的统一管理。
-通过行表达式书写分片算法，可以有效地将规则配置一同存放，更加易于浏览与存储。
-
-## 语法说明
-
-行表达式的使用非常直观，只需要在配置中使用 `${ expression }` 或 `$->{ expression }` 标识行表达式即可。
-目前支持数据节点和分片算法这两个部分的配置。
-行表达式的内容使用的是 Groovy 的语法，Groovy 能够支持的所有操作，行表达式均能够支持。
-例如：
-
-`${begin..end}` 表示范围区间
-
-`${[unit1, unit2, unit_x]}` 表示枚举值
-
-行表达式中如果出现连续多个 `${ expression }` 或 `$->{ expression }` 表达式，整个表达式最终的结果将会根据每个子表达式的结果进行笛卡尔组合。
-
-例如，以下行表达式：
-
-```groovy
-${['online', 'offline']}_table${1..3}
-```
-
-最终会解析为：
-
-```
-online_table1, online_table2, online_table3, offline_table1, offline_table2, offline_table3
-```
-
-## 配置
-
-### 数据节点
-
-对于均匀分布的数据节点，如果数据结构如下：
-
-```
-db0
-  ├── t_order0
-  └── t_order1
-db1
-  ├── t_order0
-  └── t_order1
-```
-
-用行表达式可以简化为：
-
-```
-db${0..1}.t_order${0..1}
-```
-
-或者：
-
-```
-db$->{0..1}.t_order$->{0..1}
-```
-
-对于自定义的数据节点，如果数据结构如下：
-
-```
-db0
-  ├── t_order0
-  └── t_order1
-db1
-  ├── t_order2
-  ├── t_order3
-  └── t_order4
-```
-
-用行表达式可以简化为：
-
-```
-db0.t_order${0..1},db1.t_order${2..4}
-```
-
-或者：
-
-```
-db0.t_order$->{0..1},db1.t_order$->{2..4}
-```
-
-对于有前缀的数据节点，也可以通过行表达式灵活配置，如果数据结构如下：
-
-```
-db0
-  ├── t_order_00
-  ├── t_order_01
-  ├── t_order_02
-  ├── t_order_03
-  ├── t_order_04
-  ├── t_order_05
-  ├── t_order_06
-  ├── t_order_07
-  ├── t_order_08
-  ├── t_order_09
-  ├── t_order_10
-  ├── t_order_11
-  ├── t_order_12
-  ├── t_order_13
-  ├── t_order_14
-  ├── t_order_15
-  ├── t_order_16
-  ├── t_order_17
-  ├── t_order_18
-  ├── t_order_19
-  └── t_order_20
-db1
-  ├── t_order_00
-  ├── t_order_01
-  ├── t_order_02
-  ├── t_order_03
-  ├── t_order_04
-  ├── t_order_05
-  ├── t_order_06
-  ├── t_order_07
-  ├── t_order_08
-  ├── t_order_09
-  ├── t_order_10
-  ├── t_order_11
-  ├── t_order_12
-  ├── t_order_13
-  ├── t_order_14
-  ├── t_order_15
-  ├── t_order_16
-  ├── t_order_17
-  ├── t_order_18
-  ├── t_order_19
-  └── t_order_20
-```
-
-可以使用分开配置的方式，先配置包含前缀的数据节点，再配置不含前缀的数据节点，再利用行表达式笛卡尔积的特性，自动组合即可。
-上面的示例，用行表达式可以简化为：
-
-```
-db${0..1}.t_order_0${0..9}, db${0..1}.t_order_${10..20}
-```
-
-或者：
-
-```
-db$->{0..1}.t_order_0$->{0..9}, db$->{0..1}.t_order_$->{10..20}
-```
-
-### 分片算法
-
-对于只有一个分片键的使用 `=` 和 `IN` 进行分片的 SQL，可以使用行表达式代替编码方式配置。
-
-行表达式内部的表达式本质上是一段 Groovy 代码，可以根据分片键进行计算的方式，返回相应的真实数据源或真实表名称。
-
-例如：分为 10 个库，尾数为 0 的路由到后缀为 0 的数据源， 尾数为 1 的路由到后缀为 1 的数据源，以此类推。用于表示分片算法的行表达式为：
-
-```
-ds${id % 10}
-```
-
-或者：
-
-```
-ds$->{id % 10}
-```
diff --git a/docs/document/content/features/sharding/concept/inline-expression.en.md b/docs/document/content/features/sharding/concept/inline-expression.en.md
deleted file mode 100644
index 8b05f14b6ee..00000000000
--- a/docs/document/content/features/sharding/concept/inline-expression.en.md
+++ /dev/null
@@ -1,173 +0,0 @@
-+++
-title = "Inline Expression"
-weight = 4
-+++
-
-## Motivation
-
-Configuration simplicity and unity are two main problems that inline expression intends to solve.
-
-In complex sharding rules, with more data nodes, a large number of configuration repetitions make configurations difficult to maintain. 
-Inline expressions can simplify data node configuration work.
-
-Java codes are not helpful in the unified management of common configurations. 
-Writing sharding algorithms with inline expressions, users can store rules together, making them easier to be browsed and stored.
-
-## Syntax Explanation
-
-The use of inline expressions is really direct. 
-Users only need to configure `${ expression }` or `$->{ expression }` to identify them. 
-ShardingSphere currently supports the configurations of data nodes and sharding algorithms. 
-Inline expressions use Groovy syntax, which can support all kinds of operations, including inline expressions. 
-For example:
-
-`${begin..end}` means range
-
-`${[unit1, unit2, unit_x]}` means enumeration
-
-If there are many continuous `${ expression }` or `$->{ expression }` expressions, 
-according to each sub-expression result, the ultimate result of the whole expression will be in cartesian combination.
-
-For example, the following inline expression:
-
-```groovy
-${['online', 'offline']}_table${1..3}
-```
-
-Will be parsed as:
-
-```
-online_table1, online_table2, online_table3, offline_table1, offline_table2, offline_table3
-```
-
-## Configuration
-
-### Data Node
-
-For evenly distributed data nodes, if the data structure is as follow:
-
-```
-db0
-  ├── t_order0
-  └── t_order1
-db1
-  ├── t_order0
-  └── t_order1
-```
-
-It can be simplified by inline expression as:
-
-```
-db${0..1}.t_order${0..1}
-```
-
-Or
-
-```
-db$->{0..1}.t_order$->{0..1}
-```
-
-For self-defined data nodes, if the data structure is:
-
-```
-db0
-  ├── t_order0
-  └── t_order1
-db1
-  ├── t_order2
-  ├── t_order3
-  └── t_order4
-```
-
-It can be simplified by inline expression as:
-
-```
-db0.t_order${0..1},db1.t_order${2..4}
-```
-
-Or
-
-```
-db0.t_order$->{0..1},db1.t_order$->{2..4}
-```
-
-For data nodes with prefixes, inline expression can also be used to configure them flexibly, if the data structure is:
-
-```
-db0
-  ├── t_order_00
-  ├── t_order_01
-  ├── t_order_02
-  ├── t_order_03
-  ├── t_order_04
-  ├── t_order_05
-  ├── t_order_06
-  ├── t_order_07
-  ├── t_order_08
-  ├── t_order_09
-  ├── t_order_10
-  ├── t_order_11
-  ├── t_order_12
-  ├── t_order_13
-  ├── t_order_14
-  ├── t_order_15
-  ├── t_order_16
-  ├── t_order_17
-  ├── t_order_18
-  ├── t_order_19
-  └── t_order_20
-db1
-  ├── t_order_00
-  ├── t_order_01
-  ├── t_order_02
-  ├── t_order_03
-  ├── t_order_04
-  ├── t_order_05
-  ├── t_order_06
-  ├── t_order_07
-  ├── t_order_08
-  ├── t_order_09
-  ├── t_order_10
-  ├── t_order_11
-  ├── t_order_12
-  ├── t_order_13
-  ├── t_order_14
-  ├── t_order_15
-  ├── t_order_16
-  ├── t_order_17
-  ├── t_order_18
-  ├── t_order_19
-  └── t_order_20
-```
-
-Users can configure separately, data nodes with prefixes first, those without prefixes later, and automatically combine them with the cartesian product feature of inline expressions. 
-The example above can be simplified by inline expression as:
-
-```
-db${0..1}.t_order_0${0..9}, db${0..1}.t_order_${10..20}
-```
-
-Or
-
-```
-db$->{0..1}.t_order_0$->{0..9}, db$->{0..1}.t_order_$->{10..20}
-```
-
-### Sharding Algorithm
-
-For single sharding SQL that uses `=` and `IN`, inline expression can replace codes in configuration.
-
-Inline expression is a piece of Groovy code in essence, which can return the corresponding real data source or table name according to the computation method of sharding keys.
-
-For example, sharding keys with the last number 0 are routed to the data source with the suffix of 0, those with the last number 1 are routed to the data source with the suffix of 1, the rest goes on in the same way. 
-The inline expression used to indicate sharding algorithm is:
-
-```
-ds${id % 10}
-```
-
-Or
-
-```
-ds$->{id % 10}
-```
diff --git a/docs/document/content/features/sharding/concept/key-generator.cn.md b/docs/document/content/features/sharding/concept/key-generator.cn.md
deleted file mode 100644
index e9ad27da1d6..00000000000
--- a/docs/document/content/features/sharding/concept/key-generator.cn.md
+++ /dev/null
@@ -1,73 +0,0 @@
-+++
-title = "分布式主键"
-weight = 5
-+++
-
-## 实现动机
-
-传统数据库软件开发中，主键自动生成技术是基本需求。而各个数据库对于该需求也提供了相应的支持，比如 MySQL 的自增键，Oracle 的自增序列等。
-数据分片后，不同数据节点生成全局唯一主键是非常棘手的问题。同一个逻辑表内的不同实际表之间的自增键由于无法互相感知而产生重复主键。
-虽然可通过约束自增主键初始值和步长的方式避免碰撞，但需引入额外的运维规则，使解决方案缺乏完整性和可扩展性。
-
-目前有许多第三方解决方案可以完美解决这个问题，如 UUID 等依靠特定算法自生成不重复键，或者通过引入主键生成服务等。为了方便用户使用、满足不同用户不同使用场景的需求，
-Apache ShardingSphere 不仅提供了内置的分布式主键生成器，例如 UUID、SNOWFLAKE，还抽离出分布式主键生成器的接口，方便用户自行实现自定义的自增主键生成器。
-
-## 内置的主键生成器
-
-### UUID
-
-采用 `UUID.randomUUID()` 的方式产生分布式主键。
-
-### NanoID
-
-生成长度为 21 的字符串分布式主键。
-
-### SNOWFLAKE
-
-在分片规则配置模块可配置每个表的主键生成策略，默认使用雪花算法（snowflake）生成 64bit 的长整型数据。
-
-雪花算法是由 Twitter 公布的分布式主键生成算法，它能够保证不同进程主键的不重复性，以及相同进程主键的有序性。
-
-#### 实现原理
-
-在同一个进程中，它首先是通过时间位保证不重复，如果时间相同则是通过序列位保证。
-同时由于时间位是单调递增的，且各个服务器如果大体做了时间同步，那么生成的主键在分布式环境可以认为是总体有序的，这就保证了对索引字段的插入的高效性。
-例如 MySQL 的 Innodb 存储引擎的主键。
-
-使用雪花算法生成的主键，二进制表示形式包含 4 部分，从高位到低位分表为：1bit 符号位、41bit 时间戳位、10bit 工作进程位以及 12bit 序列号位。
-
- - 符号位（1bit）
-
-预留的符号位，恒为零。
-
- - 时间戳位（41bit）
-
-41 位的时间戳可以容纳的毫秒数是 2 的 41 次幂，一年所使用的毫秒数是：`365 * 24 * 60 * 60 * 1000`。
-通过计算可知：
-
-```java
-Math.pow(2, 41) / (365 * 24 * 60 * 60 * 1000L);
-```
-
-结果约等于 69.73 年。
-Apache ShardingSphere 的雪花算法的时间纪元从 `2016年11月1日` 零点开始，可以使用到 2086 年，相信能满足绝大部分系统的要求。
-
- - 工作进程位（10bit）
-
-该标志在 Java 进程内是唯一的，如果是分布式应用部署应保证每个工作进程的 id 是不同的。
-该值默认为 0，可通过属性设置。
-
- - 序列号位（12bit）
-
-该序列是用来在同一个毫秒内生成不同的 ID。如果在这个毫秒内生成的数量超过 4096 (2 的 12 次幂)，那么生成器会等待到下个毫秒继续生成。
-
-雪花算法主键的详细结构见下图。
-
-![雪花算法](https://shardingsphere.apache.org/document/current/img/sharding/snowflake_cn_v2.png)
-
-#### 时钟回拨
-
-服务器时钟回拨会导致产生重复序列，因此默认分布式主键生成器提供了一个最大容忍的时钟回拨毫秒数。
-如果时钟回拨的时间超过最大容忍的毫秒数阈值，则程序报错；如果在可容忍的范围内，默认分布式主键生成器会等待时钟同步到最后一次主键生成的时间后再继续工作。
-最大容忍的时钟回拨毫秒数的默认值为 0，可通过属性设置。
-
diff --git a/docs/document/content/features/sharding/concept/key-generator.en.md b/docs/document/content/features/sharding/concept/key-generator.en.md
deleted file mode 100644
index edd410f8367..00000000000
--- a/docs/document/content/features/sharding/concept/key-generator.en.md
+++ /dev/null
@@ -1,80 +0,0 @@
-+++
-title = "Distributed Primary Key"
-weight = 5
-+++
-
-## Motivation
-
-In the development of traditional database software, the automatic sequence generation technology is a basic requirement. 
-All kinds of databases have provided corresponding support for this requirement, such as MySQL auto-increment key, Oracle auto-increment sequence and so on. 
-It is a tricky problem that there is only one sequence generated by different data nodes after sharding. 
-Auto-increment keys in different physical tables in the same logic table can not perceive each other and thereby generate repeated sequences. 
-It is possible to avoid clashes by restricting the initiative value and increasing the step of auto-increment key. 
-But introducing extra operation rules can make the solution lack integrity and scalability.
-
-Currently, there are many third-party solutions that can solve this problem perfectly, 
-(such as UUID and others) relying on some particular algorithms to generate unrepeated keys or introducing sequence generation services. 
-We have provided several built-in key generators, such as UUID, SNOWFLAKE. 
-Besides, we have also extracted a key generator interface to make users implement self-defined key generator.
-
-## Built-In Key Generator
-
-### UUID
-
-Use `UUID.randomUUID()` to generate the distributed key.
-
-### NanoID
-
-Generate a string of length 21 distributed key.
-
-### SNOWFLAKE
-
-Users can configure the strategy of each table in sharding rule configuration module, with default snowflake algorithm generating 64bit long integral data.
-
-As the distributed sequence generation algorithm published by Twitter, 
-snowflake algorithm can ensure sequences of different processes do not repeat and those of the same process are ordered.
-
-### Principle
-
-In the same process, it makes sure that IDs do not repeat through time, or through order if the time is identical. 
-In the same time,with monotonously increasing time, if servers are generally synchronized, 
-generated sequences are generally assumed to be ordered in a distributed environment. 
-This can guarantee the effectiveness in index field insertion, like the sequence of MySQL Innodb storage engine.
-
-In the sequence generated with snowflake algorithm, binary form has 4 parts, 1 bit sign, 41bit timestamp, 10bit work ID and 12bit sequence number from high to low.
-
-- sign bit (1bit)
-
-Reserved sign bit, constantly to be zero.
-
-- timestamp bit (41bit)
-
-41bit timestamp can contain 2 to the power of 41 milliseconds. One year can use `365 * 24 * 60 * 60 * 1000` milliseconds. We can see from the calculation:
-
-```java
-Math.pow(2, 41) / (365 * 24 * 60 * 60 * 1000L);
-```
-
-The result is approximately equal to 69.73 years. 
-Apache ShardingSphere snowflake algorithm starts from November 1st, 2016, and can be used until 2086, which we believe can satisfy the requirement of most systems.
-
-- work ID bit (10bit)
-
-The sign is the only one in Java process. If applied in distributed deployment, each work ID should be different. 
-The default value is 0 and can be set through properties.
-
-- sequence number bit (12bit)
-
-The sequence number is used to generate different IDs in a millisecond. 
-If the number generated in that millisecond exceeds 4,096 (2 to the power of 12), the generator will wait till the next millisecond to continue.
-
-Please refer to the following picture for the detailed structure of snowflake algorithm sequence.
-
-![Snowflake](https://shardingsphere.apache.org/document/current/img/sharding/snowflake_en_v3.png)
-
-#### Clock-Back
-
-The clock-back of server can generate repeated sequence, so the default distributed sequence generator has provided a maximum clock-back millisecond. 
-If the clock-back time has exceeded it, the program will report error. If it is within the tolerance range, 
-the generator will wait till after the last generation time and then continue to work. 
-The default maximum clock-back millisecond is 0 and can be set through properties.
diff --git a/docs/document/content/features/sharding/concept/sharding.cn.md b/docs/document/content/features/sharding/concept/sharding.cn.md
deleted file mode 100644
index 7b95966505e..00000000000
--- a/docs/document/content/features/sharding/concept/sharding.cn.md
+++ /dev/null
@@ -1,50 +0,0 @@
-+++
-title = "分片"
-weight = 3
-+++
-
-## 分片键
-
-用于将数据库（表）水平拆分的数据库字段。
-例：将订单表中的订单主键的尾数取模分片，则订单主键为分片字段。
-SQL 中如果无分片字段，将执行全路由，性能较差。
-除了对单分片字段的支持，Apache ShardingSphere 也支持根据多个字段进行分片。
-
-## 分片算法
-
-用于将数据分片的算法，支持 `=`、`>=`、`<=`、`>`、`<`、`BETWEEN` 和 `IN` 进行分片。
-分片算法可由开发者自行实现，也可使用 Apache ShardingSphere 内置的分片算法语法糖，灵活度非常高。
-
-### 自动化分片算法
-
-分片算法语法糖，用于便捷的托管所有数据节点，使用者无需关注真实表的物理分布。
-包括取模、哈希、范围、时间等常用分片算法的实现。
-
-### 自定义分片算法
-
-提供接口让应用开发者自行实现与业务实现紧密相关的分片算法，并允许使用者自行管理真实表的物理分布。
-自定义分片算法又分为：
-
-- 标准分片算法
-
-用于处理使用单一键作为分片键的 `=`、`IN`、`BETWEEN AND`、`>`、`<`、`>=`、`<=` 进行分片的场景。
-
-- 复合分片算法
-
-用于处理使用多键作为分片键进行分片的场景，包含多个分片键的逻辑较复杂，需要应用开发者自行处理其中的复杂度。
-
-- Hint 分片算法
-
-用于处理使用 `Hint` 行分片的场景。
-
-## 分片策略
-
-包含分片键和分片算法，由于分片算法的独立性，将其独立抽离。
-真正可用于分片操作的是分片键 + 分片算法，也就是分片策略。
-
-## 强制分片路由
-
-对于分片字段并非由 SQL 而是其他外置条件决定的场景，可使用 SQL Hint 注入分片值。
-例：按照员工登录主键分库，而数据库中并无此字段。
-SQL Hint 支持通过 Java API 和 SQL 注释（待实现）两种方式使用。
-详情请参见[强制分片路由](/cn/features/sharding/concept/hint/)。
diff --git a/docs/document/content/features/sharding/concept/sharding.en.md b/docs/document/content/features/sharding/concept/sharding.en.md
deleted file mode 100644
index a41f4f5c13a..00000000000
--- a/docs/document/content/features/sharding/concept/sharding.en.md
+++ /dev/null
@@ -1,52 +0,0 @@
-+++
-title = "Sharding"
-weight = 3
-+++
-
-## Sharding Key
-
-Column used to determine database (table) sharding.
-For example, in last number modulo of order ID sharding, order ID is taken as the sharding key. 
-The full route executed when there is no sharding column in SQL has a poor performance. 
-Besides single sharding column, Apache ShardingSphere also supports multiple sharding columns.
-
-## Sharding Algorithm
-
-Data sharding can be achieved by sharding algorithms through `=`, `>=`, `<=`, `>`, `<`, `BETWEEN` and `IN`.
-It can be implemented by developers themselves, or using built-in syntactic sugar of Apache ShardingSphere, with high flexibility.
-
-### Auto Sharding Algorithm
-
-It provides syntactic sugar for sharding algorithm.
-It used to manage all data nodes automatically, user do not care about the topology of physical data nodes.
-It includes lots of implementation for Mod, Hash, Range and Time Interval etc.
-
-### User-Defined Sharding Algorithm
-
-It provides interfaces for developers to implement the sharding algorithm related to business implementation, and allows users to manage the physical topology physical data nodes by themselves.
-It includes:
-
-- Standard Sharding Algorithm
-
-It is to process the sharding case in which single sharding keys `=`, `IN`, `BETWEEN AND`, `>`, `<`, `>=`, `<=` are used.
-
-- Complex Keys Sharding Algorithm
-
-It is to process the sharding case in which multiple sharding keys are used.
-It has a relatively complex logic that requires developers to deal by themselves.
-
-- Hint Sharding Algorithm
-
-It is to process the sharding case in which Hint is used.
-
-## Sharding Strategy
-
-It includes the sharding key and the sharding algorithm, and the latter one is extracted out for its independence. 
-Only sharding key + sharding algorithm can be used in sharding operation.
-
-## SQL Hint
-
-In the case that the sharding column is not decide by SQL but other external conditions, SQL hint can be used to inject sharding value. 
-For example, databases are shard according to the staff’s ID, but column does not exist in the database. 
-SQL Hint can be used by two ways, Java API and SQL comment (TODO).
-Please refer to [Hint](/en/features/sharding/concept/hint/) for more details.
diff --git a/docs/document/content/features/sharding/concept/table.cn.md b/docs/document/content/features/sharding/concept/table.cn.md
deleted file mode 100644
index 11bb7ba1e2b..00000000000
--- a/docs/document/content/features/sharding/concept/table.cn.md
+++ /dev/null
@@ -1,63 +0,0 @@
-+++
-title = "表"
-weight = 1
-+++
-
-表是透明化数据分片的关键概念。
-Apache ShardingSphere 通过提供多样化的表类型，适配不同场景下的数据分片需求。
-
-## 逻辑表
-
-相同结构的水平拆分数据库（表）的逻辑名称，是 SQL 中表的逻辑标识。
-例：订单数据根据主键尾数拆分为 10 张表，分别是 `t_order_0` 到 `t_order_9`，他们的逻辑表名为 `t_order`。
-
-## 真实表
-
-在水平拆分的数据库中真实存在的物理表。
-即上个示例中的 `t_order_0` 到 `t_order_9`。
-
-## 绑定表
-
-指分片规则一致的一组分片表。
-使用绑定表进行多表关联查询时，必须使用分片键进行关联，否则会出现笛卡尔积关联或跨库关联，从而影响查询效率。
-例如：`t_order` 表和 `t_order_item` 表，均按照 `order_id` 分片，并且使用 `order_id` 进行关联，则此两张表互为绑定表关系。
-绑定表之间的多表关联查询不会出现笛卡尔积关联，关联查询效率将大大提升。
-举例说明，如果 SQL 为：
-
-```sql
-SELECT i.* FROM t_order o JOIN t_order_item i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);
-```
-
-在不配置绑定表关系时，假设分片键 `order_id` 将数值 10 路由至第 0 片，将数值 11 路由至第 1 片，那么路由后的 SQL 应该为 4 条，它们呈现为笛卡尔积：
-
-```sql
-SELECT i.* FROM t_order_0 o JOIN t_order_item_0 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);
-
-SELECT i.* FROM t_order_0 o JOIN t_order_item_1 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);
-
-SELECT i.* FROM t_order_1 o JOIN t_order_item_0 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);
-
-SELECT i.* FROM t_order_1 o JOIN t_order_item_1 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);
-```
-
-在配置绑定表关系，并且使用 `order_id` 进行关联后，路由的 SQL 应该为 2 条：
-
-```sql
-SELECT i.* FROM t_order_0 o JOIN t_order_item_0 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);
-
-SELECT i.* FROM t_order_1 o JOIN t_order_item_1 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);
-```
-
-其中 `t_order` 表由于指定了分片条件，ShardingSphere 将会以它作为整个绑定表的主表。
-所有路由计算将会只使用主表的策略，那么 `t_order_item` 表的分片计算将会使用 `t_order` 的条件。
-
-## 广播表
-
-指所有的分片数据源中都存在的表，表结构及其数据在每个数据库中均完全一致。
-适用于数据量不大且需要与海量数据的表进行关联查询的场景，例如：字典表。
-
-## 单表
-
-指所有的分片数据源中仅唯一存在的表。
-适用于数据量不大且无需分片的表。
-用户需要保证单表的唯一性，如果单表在同一个数据库的同一个 schema 下重复，ShardingSphere 只会加载第一个单表用于 SQL 路由。
diff --git a/docs/document/content/features/sharding/concept/table.en.md b/docs/document/content/features/sharding/concept/table.en.md
deleted file mode 100644
index c0b4fb3f5de..00000000000
--- a/docs/document/content/features/sharding/concept/table.en.md
+++ /dev/null
@@ -1,63 +0,0 @@
-+++
-title = "Table"
-weight = 1
-+++
-
-Table is the core concept of data sharding transparently. 
-There are diversified tables provided for different data sharding requirements by Apache ShardingSphere. 
-
-## Logic Table
-
-The logical name of the horizontal sharding databases (tables) with the same schema, it is the logical table identification in SQL.
-For instance, the data of order is divided into 10 tables according to the last number of the primary key, and they are from `t_order_0` to `t_order_9`, whose logic name is `t_order`.
-
-## Actual Table
-
-The physical table that really exists in the horizontal sharding database, i.e., `t_order_0` to `t_order_9` in the instance above.
-
-## Binding Table
-
-It refers to a group of sharding tables with the same sharding rules.
-When using binding tables in multi-table correlating query, you must use the sharding key for correlation, otherwise Cartesian product correlation or cross-database correlation will appear, which will affect query efficiency.
-For example, `t_order` and `t_order_item` are both sharded by `order_id`, and use `order_id` to correlate, so they are binding tables with each other. 
-Cartesian product correlation will not appear in the multi-tables correlating query, so the query efficiency will increase greatly.
-Take this one for example, if SQL is:
-
-```sql
-SELECT i.* FROM t_order o JOIN t_order_item i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);
-```
-
-When binding table relations are not configured, suppose the sharding key `order_id` routes value 10 to sharding 0 and value 11 to sharding 1, there will be 4 SQLs in Cartesian product after routing:
-
-```sql
-SELECT i.* FROM t_order_0 o JOIN t_order_item_0 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);
-
-SELECT i.* FROM t_order_0 o JOIN t_order_item_1 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);
-
-SELECT i.* FROM t_order_1 o JOIN t_order_item_0 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);
-
-SELECT i.* FROM t_order_1 o JOIN t_order_item_1 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);
-```
-
-With binding table configuration and use `order_id` to correlate, there should be 2 SQLs after routing:
-
-```sql
-SELECT i.* FROM t_order_0 o JOIN t_order_item_0 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);
-
-SELECT i.* FROM t_order_1 o JOIN t_order_item_1 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);
-```
-
-In them, since table `t_order` specifies sharding conditions, it will be taken by ShardingSphere as the primary table of query. 
-All the route computations will only use the sharding strategy of the primary table, so sharding computation of `t_order_item` table will use the conditions of `t_order`.
-
-## Broadcast Table
-
-It refers to tables that exist in all sharding database sources. 
-The schema and data must consist in each database. 
-It can be applied to the small data volume that needs to correlate with big data tables to query, dictionary table for example.
-
-## Single Table
-
-It refers to only one table that exists in all sharding database sources. 
-It is suitable for little data in table without sharding.
-Users need to ensure that single table is unique. If single table is repeated under the same schema in the same database, ShardingSphere will only load the first single table for sql route.
diff --git a/docs/document/content/features/sharding/use-norms/_index.cn.md b/docs/document/content/features/sharding/use-norms/_index.cn.md
deleted file mode 100644
index 819cf227b55..00000000000
--- a/docs/document/content/features/sharding/use-norms/_index.cn.md
+++ /dev/null
@@ -1,9 +0,0 @@
-+++
-title = "使用规范"
-weight = 2
-+++
-
-## 背景
-
-虽然 Apache ShardingSphere 希望能够完全兼容所有的 SQL 以及单机数据库，但分布式为数据库带来了更加复杂的场景。
-Apache ShardingSphere 希望能够优先解决海量数据 OLTP 的问题，OLAP 的相关支持，会一点一点的逐渐完善。
diff --git a/docs/document/content/features/sharding/use-norms/_index.en.md b/docs/document/content/features/sharding/use-norms/_index.en.md
deleted file mode 100644
index 2a6d525d651..00000000000
--- a/docs/document/content/features/sharding/use-norms/_index.en.md
+++ /dev/null
@@ -1,9 +0,0 @@
-+++
-title = "Use Norms"
-weight = 2
-+++
-
-## Background
-
-Though Apache ShardingSphere intends to be compatible with all the SQLs and stand-alone databases, the distributed scenario has brought more complex situations to the database. 
-Apache ShardingSphere wants to solve massive data OLTP problem first and complete relevant OLAP support problem little by little.
diff --git a/docs/document/content/features/sharding/use-norms/pagination.cn.md b/docs/document/content/features/sharding/use-norms/pagination.cn.md
deleted file mode 100644
index 98370bd2144..00000000000
--- a/docs/document/content/features/sharding/use-norms/pagination.cn.md
+++ /dev/null
@@ -1,91 +0,0 @@
-+++
-title = "分页"
-weight = 2
-+++
-
-完全支持 MySQL、PostgreSQL 和 Oracle 的分页查询，SQLServer 由于分页查询较为复杂，仅部分支持。
-
-## 分页性能
-
-### 性能瓶颈
-
-查询偏移量过大的分页会导致数据库获取数据性能低下，以 MySQL 为例：
-
-```sql
-SELECT * FROM t_order ORDER BY id LIMIT 1000000, 10
-```
-
-这句 SQL 会使得 MySQL 在无法利用索引的情况下跳过 1,000,000 条记录后，再获取 10 条记录，其性能可想而知。
-而在分库分表的情况下（假设分为2个库），为了保证数据的正确性，SQL 会改写为：
-
-```sql
-SELECT * FROM t_order ORDER BY id LIMIT 0, 1000010
-```
-
-即将偏移量前的记录全部取出，并仅获取排序后的最后 10 条记录。这会在数据库本身就执行很慢的情况下，进一步加剧性能瓶颈。
-因为原SQL仅需要传输 10 条记录至客户端，而改写之后的SQL则会传输 `1,000,010 * 2` 的记录至客户端。
-
-### ShardingSphere 的优化
-
-ShardingSphere 进行了 2 个方面的优化。
-
-首先，采用流式处理 + 归并排序的方式来避免内存的过量占用。由于 SQL 改写不可避免的占用了额外的带宽，但并不会导致内存暴涨。
-与直觉不同，大多数人认为 ShardingSphere 会将 `1,000,010 * 2` 记录全部加载至内存，进而占用大量内存而导致内存溢出。
-但由于每个结果集的记录是有序的，因此 ShardingSphere 每次比较仅获取各个分片的当前结果集记录，驻留在内存中的记录仅为当前路由到的分片的结果集的当前游标指向而已。
-按归并思想合并 m 个长度为 n 的已排序数组，时间复杂度为 `O(mn(log m))`，一般分片数量 m 都较小，可以认为时间复杂度为 `O(n)`，性能损耗很小。
-
-其次，ShardingSphere 对仅落至单分片的查询进行进一步优化。
-落至单分片查询的请求并不需要改写 SQL 也可以保证记录的正确性，因此在此种情况下，ShardingSphere 并未进行 SQL 改写，从而达到节省带宽的目的。
-
-## 分页方案优化
-
-由于 LIMIT 并不能通过索引查询数据，因此如果可以保证 ID 的连续性，通过 ID 进行分页是比较好的解决方案：
-
-```sql
-SELECT * FROM t_order WHERE id > 100000 AND id <= 100010 ORDER BY id
-```
-
-或通过记录上次查询结果的最后一条记录的 ID 进行下一页的查询：
-
-```sql
-SELECT * FROM t_order WHERE id > 100000 LIMIT 10
-```
-
-## 分页子查询
-
-Oracle 和 SQLServer 的分页都需要通过子查询来处理，ShardingSphere 支持分页相关的子查询。
-
-- Oracle
-
-支持使用 rownum 进行分页：
-
-```sql
-SELECT * FROM (SELECT row_.*, rownum rownum_ FROM (SELECT o.order_id as order_id FROM t_order o JOIN t_order_item i ON o.order_id = i.order_id) row_ WHERE rownum <= ?) WHERE rownum > ?
-```
-
-目前不支持 rownum + BETWEEN 的分页方式。
-
-- SQLServer
-
-支持使用 TOP + ROW_NUMBER() OVER 配合进行分页：
-
-```sql
-SELECT * FROM (SELECT TOP (?) ROW_NUMBER() OVER (ORDER BY o.order_id DESC) AS rownum, * FROM t_order o) AS temp WHERE temp.rownum > ? ORDER BY temp.order_id
-```
-
-支持 SQLServer 2012 之后的 OFFSET FETCH 的分页方式：
-
-```sql
-SELECT * FROM t_order o ORDER BY id OFFSET ? ROW FETCH NEXT ? ROWS ONLY
-```
-
-目前不支持使用 WITH xxx AS (SELECT ...) 的方式进行分页。由于 Hibernate 自动生成的 SQLServer 分页语句使用了 WITH 语句，因此目前并不支持基于 Hibernate 的 SQLServer 分页。
-目前也不支持使用两个 TOP + 子查询的方式实现分页。
-
-- MySQL, PostgreSQL
-
-MySQL 和 PostgreSQL 都支持 LIMIT 分页，无需子查询：
-
-```sql
-SELECT * FROM t_order o ORDER BY id LIMIT ? OFFSET ?
-```
diff --git a/docs/document/content/features/sharding/use-norms/pagination.en.md b/docs/document/content/features/sharding/use-norms/pagination.en.md
deleted file mode 100644
index ac4fdbe342a..00000000000
--- a/docs/document/content/features/sharding/use-norms/pagination.en.md
+++ /dev/null
@@ -1,86 +0,0 @@
-+++
-title = "Pagination"
-weight = 2
-+++
-
-Totally support pagination queries of MySQL, PostgreSQL and Oracle; partly support SQLServer pagination query due to its complexity.
-
-## Pagination Performance
-
-### Performance Bottleneck
-
-Pagination with query offset too high can lead to a low data accessibility, take MySQL as an example: 
-
-```sql
-SELECT * FROM t_order ORDER BY id LIMIT 1000000, 10
-```
-
-This SQL will make MySQL acquire another 10 records after skipping 1,000,000 records when it is not able to use indexes. Its performance can thus be deduced. In sharding databases and sharding tables (suppose there are two databases), to ensure the data correctness, the SQL will be rewritten as this:
-
-```sql
-SELECT * FROM t_order ORDER BY id LIMIT 0, 1000010
-```
-
-It also means taking out all the records prior to the offset and only acquire the last 10 records after ordering. It will further aggravate the performance bottleneck effect when the database is already slow in execution. The reason for that is the former SQL only needs to transmit 10 records to the user end, but now it will transmit `1,000,010 * 2` records after the rewrite.
-
-### Optimization of ShardingSphere
-
-ShardingSphere has optimized in two ways.
-
-Firstly, it adopts stream process + merger ordering to avoid excessive memory occupation. SQL rewrite unavoidably occupies extra bandwidth, but it will not lead to sharp increase of memory occupation. Most people may assume that ShardingSphere would upload all the `1,000,010 * 2` records to the memory and occupy a large amount of it, which can lead to memory overflow. But each ShardingSphere comparison only acquires current result set record of each shard, since result set records have their own order.
-The record stored in the memory is only the current position pointed by the cursor in the result set of the shard routed to. 
-For the item to be sorted which has its own order, merger ordering only has the time complexity of `O(mn(log m))`, and the number of shard m is generally small enough to be considered as `O(n)`, with a very low performance consumption.
-
-Secondly, ShardingSphere further optimizes the query that only falls into single shards. Requests of this kind can guarantee the correctness of records without rewriting SQLs. Under this kind of situation, ShardingSphere will not do that in order to save the bandwidth.
-
-## Pagination Solution Optimization
-
-For LIMIT cannot search for data through indexes, if the ID continuity can be guaranteed, pagination by ID is a better solution:
-
-```sql
-SELECT * FROM t_order WHERE id > 100000 AND id <= 100010 ORDER BY id
-```
-
-Or use the ID of last record of the former query result to query the next page:
-
-```sql
-SELECT * FROM t_order WHERE id > 100000 LIMIT 10
-```
-
-## Pagination Sub-query
-
-Both Oracle and SQLServer pagination need to be processed by sub-query, ShardingSphere supports pagination related sub-query.
-
-- Oracle
-
-Support rownum pagination:
-
-```sql
-SELECT * FROM (SELECT row_.*, rownum rownum_ FROM (SELECT o.order_id as order_id FROM t_order o JOIN t_order_item i ON o.order_id = i.order_id) row_ WHERE rownum <= ?) WHERE rownum > ?
-```
-
-Do not support rownum + BETWEEN pagination for now.
-
-- SQLServer
-
-Support TOP + ROW_NUMBER() OVER pagination:
-
-```sql
-SELECT * FROM (SELECT TOP (?) ROW_NUMBER() OVER (ORDER BY o.order_id DESC) AS rownum, * FROM t_order o) AS temp WHERE temp.rownum > ? ORDER BY temp.order_id
-```
-
-Support OFFSET FETCH pagination after SQLServer 2012:
-
-```sql
-SELECT * FROM t_order o ORDER BY id OFFSET ? ROW FETCH NEXT ? ROWS ONLY
-```
-
-Do not support `WITH xxx AS (SELECT ...)` pagination. Because SQLServer automatically generated by Hibernate uses WITH statements, Hibernate SQLServer pagination or two TOP + sub-query pagination is not available now.
-
-- MySQL, PostgreSQL
-
-Both MySQL and PostgreSQL support LIMIT pagination, no need for sub-query:
-
-```sql
-SELECT * FROM t_order o ORDER BY id LIMIT ? OFFSET ?
-```
diff --git a/docs/document/content/features/sharding/use-norms/sql.cn.md b/docs/document/content/features/sharding/use-norms/sql.cn.md
deleted file mode 100644
index 2a6d9ce3529..00000000000
--- a/docs/document/content/features/sharding/use-norms/sql.cn.md
+++ /dev/null
@@ -1,175 +0,0 @@
-+++
-title = "SQL"
-weight = 1
-+++
-
-## SQL 支持程度
-
-兼容全部常用的**路由至单数据节点**的 SQL；
-**路由至多数据节点**的 SQL 由于场景复杂，分为稳定支持、实验性支持和不支持这三种情况。
-
-### 稳定支持
-
-全面支持 DML、DDL、DCL、TCL 和常用 DAL。
-支持分页、去重、排序、分组、聚合、表关联等复杂查询。
-支持 PostgreSQL 和 openGauss 数据库 SCHEMA DDL 和 DML 语句。 
-
-#### 常规查询
-
-- SELECT 主语句
-
-```sql
-SELECT select_expr [, select_expr ...] FROM table_reference [, table_reference ...]
-[WHERE predicates]
-[GROUP BY {col_name | position} [ASC | DESC], ...]
-[ORDER BY {col_name | position} [ASC | DESC], ...]
-[LIMIT {[offset,] row_count | row_count OFFSET offset}]
-```
-
-- select_expr
-
-```sql
-* | 
-[DISTINCT] COLUMN_NAME [AS] [alias] | 
-(MAX | MIN | SUM | AVG)(COLUMN_NAME | alias) [AS] [alias] | 
-COUNT(* | COLUMN_NAME | alias) [AS] [alias]
-```
-
-- table_reference
-
-```sql
-tbl_name [AS] alias] [index_hint_list]
-| table_reference ([INNER] | {LEFT|RIGHT} [OUTER]) JOIN table_factor [JOIN ON conditional_expr | USING (column_list)]
-```
-
-#### 子查询
-
-子查询和外层查询同时指定分片键，且分片键的值保持一致时，由内核提供稳定支持。
-
-例如：
-
-```sql
-SELECT * FROM (SELECT * FROM t_order WHERE order_id = 1) o WHERE o.order_id = 1;
-```
-
-用于[分页](/cn/features/sharding/use-norms/pagination)的子查询，由内核提供稳定支持。
-
-例如：
-
-```sql
-SELECT * FROM (SELECT row_.*, rownum rownum_ FROM (SELECT * FROM t_order) row_ WHERE rownum <= ?) WHERE rownum > ?;
-```
-
-#### 运算表达式中包含分片键
-
-当分片键处于运算表达式中时，无法通过 SQL `字面` 提取用于分片的值，将导致全路由。
-
-例如，假设 `create_time` 为分片键：
-
-```sql
-SELECT * FROM t_order WHERE to_date(create_time, 'yyyy-mm-dd') = '2019-01-01';
-```
-
-### 实验性支持
-
-实验性支持特指使用 Federation 执行引擎提供支持。
-该引擎处于快速开发中，用户虽基本可用，但仍需大量优化，是实验性产品。
-
-#### 子查询
-
-子查询和外层查询未同时指定分片键，或分片键的值不一致时，由 Federation 执行引擎提供支持。
-
-例如：
-
-```sql
-SELECT * FROM (SELECT * FROM t_order) o;
-
-SELECT * FROM (SELECT * FROM t_order) o WHERE o.order_id = 1;
-
-SELECT * FROM (SELECT * FROM t_order WHERE order_id = 1) o;
-
-SELECT * FROM (SELECT * FROM t_order WHERE order_id = 1) o WHERE o.order_id = 2;
-```
-
-#### 跨库关联查询
-
-当关联查询中的多个表分布在不同的数据库实例上时，由 Federation 执行引擎提供支持。
-假设 `t_order` 和 `t_order_item` 是多数据节点的分片表，并且未配置绑定表规则，`t_user` 和 `t_user_role` 是分布在不同的数据库实例上的单表，那么 Federation 执行引擎能够支持如下常用的关联查询：
-
-```sql
-SELECT * FROM t_order o INNER JOIN t_order_item i ON o.order_id = i.order_id WHERE o.order_id = 1;
-
-SELECT * FROM t_order o INNER JOIN t_user u ON o.user_id = u.user_id WHERE o.user_id = 1;
-
-SELECT * FROM t_order o LEFT JOIN t_user_role r ON o.user_id = r.user_id WHERE o.user_id = 1;
-
-SELECT * FROM t_order_item i LEFT JOIN t_user u ON i.user_id = u.user_id WHERE i.user_id = 1;
-
-SELECT * FROM t_order_item i RIGHT JOIN t_user_role r ON i.user_id = r.user_id WHERE i.user_id = 1;
-
-SELECT * FROM t_user u RIGHT JOIN t_user_role r ON u.user_id = r.user_id WHERE u.user_id = 1;
-```
-
-### 不支持
-
-以下 CASE WHEN 语句不支持：
-
-* `CASE WHEN` 中包含子查询
-* `CASE WHEN` 中使用逻辑表名（请使用表别名）
-
-## SQL 示例
-
-| 稳定支持的 SQL                                                                                | 必要条件                          |
-| ------------------------------------------------------------------------------------------- | -------------------------------- |
-| SELECT * FROM tbl_name                                                                      |                                  |
-| SELECT * FROM tbl_name WHERE (col1 = ? or col2 = ?) and col3 = ?                            |                                  |
-| SELECT * FROM tbl_name WHERE col1 = ? ORDER BY col2 DESC LIMIT ?                            |                                  |
-| SELECT COUNT(*), SUM(col1), MIN(col1), MAX(col1), AVG(col1) FROM tbl_name WHERE col1 = ?    |                                  |
-| SELECT COUNT(col1) FROM tbl_name WHERE col2 = ? GROUP BY col1 ORDER BY col3 DESC LIMIT ?, ? |                                  |
-| SELECT DISTINCT * FROM tbl_name WHERE col1 = ?                                              |                                  |
-| SELECT COUNT(DISTINCT col1), SUM(DISTINCT col1) FROM tbl_name                               |                                  |
-| (SELECT * FROM tbl_name)                                                                    |                                  |
-| SELECT * FROM (SELECT * FROM tbl_name WHERE col1 = ?) o WHERE o.col1 = ?                    | 子查询和外层查询在同一分片后的数据节点  |
-| INSERT INTO tbl_name (col1, col2,...) VALUES (?, ?, ....)                                   |                                  |
-| INSERT INTO tbl_name VALUES (?, ?,....)                                                     |                                  |
-| INSERT INTO tbl_name (col1, col2, ...) VALUES(1 + 2, ?, ...)                                |                                  |
-| INSERT INTO tbl_name (col1, col2, ...) VALUES (?, ?, ....), (?, ?, ....)                    |                                  |
-| INSERT INTO tbl_name (col1, col2, ...) SELECT col1, col2, ... FROM tbl_name WHERE col3 = ?  | INSERT 表和 SELECT 表相同表或绑定表  |
-| REPLACE INTO tbl_name (col1, col2, ...) SELECT col1, col2, ... FROM tbl_name WHERE col3 = ? | REPLACE 表和 SELECT 表相同表或绑定表 |
-| UPDATE tbl_name SET col1 = ? WHERE col2 = ?                                                 |                                  |
-| DELETE FROM tbl_name WHERE col1 = ?                                                         |                                  |
-| CREATE TABLE tbl_name (col1 int, ...)                                                       |                                  |
-| ALTER TABLE tbl_name ADD col1 varchar(10)                                                   |                                  |
-| DROP TABLE tbl_name                                                                         |                                  |
-| TRUNCATE TABLE tbl_name                                                                     |                                  |
-| CREATE INDEX idx_name ON tbl_name                                                           |                                  |
-| DROP INDEX idx_name ON tbl_name                                                             |                                  |
-| DROP INDEX idx_name                                                                         |                                  |
-
-***
-
-| 实验性支持的 SQL                                                           | 必要条件                          |
-|--------------------------------------------------------------------------| -------------------------------- |
-| SELECT * FROM (SELECT * FROM tbl_name) o                                 |                                  |
-| SELECT * FROM (SELECT * FROM tbl_name) o WHERE o.col1 = ?                |                                  |
-| SELECT * FROM (SELECT * FROM tbl_name WHERE col1 = ?) o                  |                                  |
-| SELECT * FROM (SELECT * FROM tbl_name WHERE col1 = ?) o WHERE o.col1 = ? | 子查询和外层查询不在同一分片后的数据节点|
-| SELECT (SELECT MAX(col1) FROM tbl_name) a, col2 from tbl_name            |                                  |
-| SELECT SUM(DISTINCT col1), SUM(col1) FROM tbl_name                       |                                  |
-| SELECT col1, SUM(col2) FROM tbl_name GROUP BY col1 HAVING SUM(col2) > ?  |                                  |
-| SELECT col1, col2 FROM tbl_name UNION SELECT col1, col2 FROM tbl_name    |                                  |
-| SELECT col1, col2 FROM tbl_name UNION ALL SELECT col1, col2 FROM tbl_name|                                  |
-
-***
-
-| 慢 SQL                                                              | 原因                        |
-| ------------------------------------------------------------------- | -------------------------- |
-| SELECT * FROM tbl_name WHERE to_date(create_time, 'yyyy-mm-dd') = ? | 分片键在运算表达式中，导致全路由 |
-
-***
-
-| 不支持的 SQL                                                                    | 原因                                 | 解决方案   |
-| ----------------------------------------------------------------------------- | ------------------------------------ | --------- |
-| INSERT INTO tbl_name (col1, col2, ...) SELECT * FROM tbl_name WHERE col3 = ?  | SELECT 子句不支持 * 和内置分布式主键生成器 |   无      |
-| REPLACE INTO tbl_name (col1, col2, ...) SELECT * FROM tbl_name WHERE col3 = ? | SELECT 子句不支持 * 和内置分布式主键生成器 |   无      |
-| SELECT MAX(tbl_name.col1) FROM tbl_name                                       | 查询列是函数表达式时，查询列前不能使用表名   | 使用表别名 |
diff --git a/docs/document/content/features/sharding/use-norms/sql.en.md b/docs/document/content/features/sharding/use-norms/sql.en.md
deleted file mode 100644
index 9e12c00eb22..00000000000
--- a/docs/document/content/features/sharding/use-norms/sql.en.md
+++ /dev/null
@@ -1,176 +0,0 @@
-+++
-title = "SQL"
-weight = 1
-+++
-
-## SQL Supporting Status
-
-Compatible with all regular SQL when **routing to single data node**;
-**The SQL routing to multiple data nodes** is pretty complex, it divides the scenarios as totally supported, experimental supported and unsupported.
-
-### Totally Supported
-
-Fully support DML, DDL, DCL, TCL and most regular DAL.
-Support complex query with pagination, DISTINCT, ORDER BY, GROUP BY, aggregation and table JOIN.
-Support PostgreSQL and openGauss database SCHEMA DDL and DML statements.
-
-#### Regular Query
-
-- SELECT Clause
-
-```sql
-SELECT select_expr [, select_expr ...] FROM table_reference [, table_reference ...]
-[WHERE predicates]
-[GROUP BY {col_name | position} [ASC | DESC], ...]
-[ORDER BY {col_name | position} [ASC | DESC], ...]
-[LIMIT {[offset,] row_count | row_count OFFSET offset}]
-```
-
-- select_expr
-
-```sql
-*
-| [DISTINCT] COLUMN_NAME [AS] [alias]
-| (MAX | MIN | SUM | AVG)(COLUMN_NAME | alias) [AS] [alias]
-| COUNT(* | COLUMN_NAME | alias) [AS] [alias]
-```
-
-- table_reference
-
-```sql
-tbl_name [AS] alias] [index_hint_list]
-| table_reference ([INNER] | {LEFT|RIGHT} [OUTER]) JOIN table_factor [JOIN ON conditional_expr | USING (column_list)]
-```
-
-#### Subquery
-
-Stable supported when sharding keys are using in both subquery and outer query, and values of sharding keys are the same.
-
-For example:
-
-```sql
-SELECT * FROM (SELECT * FROM t_order WHERE order_id = 1) o WHERE o.order_id = 1;
-```
-
-Stable supported for subquery with [pagination](/en/features/sharding/usage-standard/pagination).
-
-For example:
-
-```sql
-SELECT * FROM (SELECT row_.*, rownum rownum_ FROM (SELECT * FROM t_order) row_ WHERE rownum <= ?) WHERE rownum > ?;
-```
-
-#### Sharding value in expression
-
-Sharding value in calculated expressions will lead to full routing.
-
-For example, if `create_time` is sharding value:
-
-```sql
-SELECT * FROM t_order WHERE to_date(create_time, 'yyyy-mm-dd') = '2019-01-01';
-```
-
-### Experimental Supported
-
-Experimental support specifically refers to use of `Federation execution engine`.
-The engine still in rapid development, basically available to users, but it still needs lots of optimization. 
-It is an experimental product.
-
-#### Subquery
-
-Experimental supported when sharding keys are not using for both subquery and outer query, or values of sharding keys are not the same.
-
-For example:
-
-```sql
-SELECT * FROM (SELECT * FROM t_order) o;
-
-SELECT * FROM (SELECT * FROM t_order) o WHERE o.order_id = 1;
-
-SELECT * FROM (SELECT * FROM t_order WHERE order_id = 1) o;
-
-SELECT * FROM (SELECT * FROM t_order WHERE order_id = 1) o WHERE o.order_id = 2;
-```
-
-#### Join with cross databases
-
-When tables in a join query are distributed on different database instances, sql statement will be supported by `Federation execution engine`.
-Assuming that `t_order` and `t_order_item` are sharding tables with multiple data nodes, and no binding table rules are configured, `t_user` and `t_user_role` are single tables that distributed on different database instances. `Federation execution engine` can support the following commonly used join query:
-
-```sql
-SELECT * FROM t_order o INNER JOIN t_order_item i ON o.order_id = i.order_id WHERE o.order_id = 1;
-
-SELECT * FROM t_order o INNER JOIN t_user u ON o.user_id = u.user_id WHERE o.user_id = 1;
-
-SELECT * FROM t_order o LEFT JOIN t_user_role r ON o.user_id = r.user_id WHERE o.user_id = 1;
-
-SELECT * FROM t_order_item i LEFT JOIN t_user u ON i.user_id = u.user_id WHERE i.user_id = 1;
-
-SELECT * FROM t_order_item i RIGHT JOIN t_user_role r ON i.user_id = r.user_id WHERE i.user_id = 1;
-
-SELECT * FROM t_user u RIGHT JOIN t_user_role r ON u.user_id = r.user_id WHERE u.user_id = 1;
-```
-
-### Unsupported
-
-CASE WHEN can not support as following:
-
-* `CASE WHEN` containing sub-query
-* `CASE WHEN` containing logical-table (instead of table alias)
-
-### SQL Example
-
-| Stable supported SQL                                                                        | Necessary conditions                                           |
-| ------------------------------------------------------------------------------------------- | -------------------------------------------------------------- |
-| SELECT * FROM tbl_name                                                                      |                                                                |
-| SELECT * FROM tbl_name WHERE (col1 = ? or col2 = ?) and col3 = ?                            |                                                                |
-| SELECT * FROM tbl_name WHERE col1 = ? ORDER BY col2 DESC LIMIT ?                            |                                                                |
-| SELECT COUNT(*), SUM(col1), MIN(col1), MAX(col1), AVG(col1) FROM tbl_name WHERE col1 = ?    |                                                                |
-| SELECT COUNT(col1) FROM tbl_name WHERE col2 = ? GROUP BY col1 ORDER BY col3 DESC LIMIT ?, ? |                                                                |
-| SELECT DISTINCT * FROM tbl_name WHERE col1 = ?                                              |                                                                |
-| SELECT COUNT(DISTINCT col1), SUM(DISTINCT col1) FROM tbl_name                               |                                                                |
-| (SELECT * FROM tbl_name)                                                                    |                                                                |
-| SELECT * FROM (SELECT * FROM tbl_name WHERE col1 = ?) o WHERE o.col1 = ?                    | Subquery and outer query in same sharded data node after route |
-| INSERT INTO tbl_name (col1, col2,...) VALUES (?, ?, ....)                                   |                                                                |
-| INSERT INTO tbl_name VALUES (?, ?,....)                                                     |                                                                |
-| INSERT INTO tbl_name (col1, col2, ...) VALUES(1 + 2, ?, ...)                                |                                                                |
-| INSERT INTO tbl_name (col1, col2, ...) VALUES (?, ?, ....), (?, ?, ....)                    |                                                                |
-| INSERT INTO tbl_name (col1, col2, ...) SELECT col1, col2, ... FROM tbl_name WHERE col3 = ?  | Inserted and selected table must be the same or binding tables |
-| REPLACE INTO tbl_name (col1, col2, ...) SELECT col1, col2, ... FROM tbl_name WHERE col3 = ? | Replaced and selected table must be the same or binding tables |
-| UPDATE tbl_name SET col1 = ? WHERE col2 = ?                                                 |                                                                |
-| DELETE FROM tbl_name WHERE col1 = ?                                                         |                                                                |
-| CREATE TABLE tbl_name (col1 int, ...)                                                       |                                                                |
-| ALTER TABLE tbl_name ADD col1 varchar(10)                                                   |                                                                |
-| DROP TABLE tbl_name                                                                         |                                                                |
-| TRUNCATE TABLE tbl_name                                                                     |                                                                |
-| CREATE INDEX idx_name ON tbl_name                                                           |                                                                |
-| DROP INDEX idx_name ON tbl_name                                                             |                                                                |
-| DROP INDEX idx_name                                                                         |                                                                |
-
-***
-
-| Experimental supported SQL                                               | Necessary conditions                                                |
-| ------------------------------------------------------------------------ |---------------------------------------------------------------------|
-| SELECT * FROM (SELECT * FROM tbl_name) o                                 |                                                                     |
-| SELECT * FROM (SELECT * FROM tbl_name) o WHERE o.col1 = ?                |                                                                     |
-| SELECT * FROM (SELECT * FROM tbl_name WHERE col1 = ?) o                  |                                                                     |
-| SELECT * FROM (SELECT * FROM tbl_name WHERE col1 = ?) o WHERE o.col1 = ? | Subquery and outer query in different sharded data node after route |
-| SELECT (SELECT MAX(col1) FROM tbl_name) a, col2 from tbl_name            |                                                                     |
-| SELECT SUM(DISTINCT col1), SUM(col1) FROM tbl_name                       |                                                                     |
-| SELECT col1, SUM(col2) FROM tbl_name GROUP BY col1 HAVING SUM(col2) > ?  |                                                                     |
-| SELECT col1, col2 FROM tbl_name UNION SELECT col1, col2 FROM tbl_name    |                                                                     |
-| SELECT col1, col2 FROM tbl_name UNION ALL SELECT col1, col2 FROM tbl_name|                                                                     |
-
-***
-
-| Slow SQL                                                            | Reason                                                       |
-| ------------------------------------------------------------------- | ------------------------------------------------------------ |
-| SELECT * FROM tbl_name WHERE to_date(create_time, 'yyyy-mm-dd') = ? | Full route because of sharding value in calculate expression |
-
-***
-
-| Unsupported SQL                                                               | Reason                                                                | Solution               |
-| ----------------------------------------------------------------------------- | --------------------------------------------------------------------- | ---------------------- |
-| INSERT INTO tbl_name (col1, col2, ...) SELECT * FROM tbl_name WHERE col3 = ?  | SELECT clause does not support *-shorthand and built-in key generator | -                      |
-| REPLACE INTO tbl_name (col1, col2, ...) SELECT * FROM tbl_name WHERE col3 = ? | SELECT clause does not support *-shorthand and built-in key generator | -                      |
-| SELECT MAX(tbl_name.col1) FROM tbl_name                                       | Use table name as column owner in function                            | Instead of table alias |
