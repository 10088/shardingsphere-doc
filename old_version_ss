commit 7b0d42bd9c79706a3ecd620658470ba79dfaf48f
Author: Zhengqiang Duan <duanzhengqiang@apache.org>
Date:   Fri Sep 24 14:36:54 2021 +0800

    update subquery document (#12675)

diff --git a/docs/document/content/features/sharding/use-norms/sql.cn.md b/docs/document/content/features/sharding/use-norms/sql.cn.md
index a6c36a88a1..f1c34af6ce 100644
--- a/docs/document/content/features/sharding/use-norms/sql.cn.md
+++ b/docs/document/content/features/sharding/use-norms/sql.cn.md
@@ -56,29 +56,31 @@ tbl_name [AS] alias] [index_hint_list]
 不支持 UNION (ALL)
 
 部分支持子查询
-* 子查询和外层查询同时指定分片键时，分片键的值必须保持一致
+* 子查询和外层查询同时指定分片键，且分片键的值保持一致时，子查询由内核支持
+* 子查询和外层查询未同时指定分片键，或分片键的值不一致时，子查询由 Federation 执行引擎（开发中）支持
 
-除了分页子查询的支持之外(详情请参考[分页](/cn/features/sharding/use-norms/pagination))，也支持同等模式的子查询。无论嵌套多少层，ShardingSphere都可以解析至第一个包含数据表的子查询，一旦在下层嵌套中再次找到包含数据表的子查询将直接抛出解析异常。
+除了分页子查询的支持之外(详情请参考[分页](/cn/features/sharding/use-norms/pagination))，也支持同等模式的子查询。
 
-例如，以下子查询可以支持：
+例如，以下子查询可以由内核支持：
 
 ```sql
-SELECT COUNT(*) FROM (SELECT * FROM t_order) o;
-SELECT COUNT(*) FROM (SELECT * FROM t_order) o WHERE o.order_id = 1;
-SELECT COUNT(*) FROM (SELECT * FROM t_order WHERE order_id = 1) o;
-SELECT COUNT(*) FROM (SELECT * FROM t_order WHERE order_id = 1) o WHERE o.order_id = 1;
-SELECT COUNT(*) FROM (SELECT * FROM t_order WHERE product_id = 1) o;
+SELECT * FROM (SELECT * FROM t_order WHERE order_id = 1) o WHERE o.order_id = 1;
+SELECT * FROM (SELECT row_.*, rownum rownum_ FROM (SELECT * FROM t_order) row_ WHERE rownum <= ?) WHERE rownum > ?;
 ```
 
-以下子查询不支持：
+以下子查询可以由 Federation 执行引擎（开发中）支持：
 
 ```sql
-SELECT COUNT(*) FROM (SELECT * FROM t_order WHERE order_id = 1) o WHERE o.order_id = 2;
+SELECT * FROM (SELECT * FROM t_order) o;
+SELECT * FROM (SELECT * FROM t_order) o WHERE o.order_id = 1;
+SELECT * FROM (SELECT * FROM t_order WHERE order_id = 1) o;
+SELECT * FROM (SELECT * FROM t_order WHERE product_id = 1) o;
+SELECT * FROM (SELECT * FROM t_order WHERE order_id = 1) o WHERE o.order_id = 2;
 ```
 
-简单来说，通过子查询进行非功能需求，在大部分情况下是可以支持的。比如分页、统计总数等；而通过子查询实现业务查询当前并不能支持。
+简单来说，通过子查询进行非功能需求，在大部分情况下是可以由内核支持的，比如分页、统计总数等。而通过子查询实现复杂的业务查询，需要由 Federation 执行引擎（开发中）支持。
 
-不支持包含schema的SQL。因为ShardingSphere的理念是像使用一个数据源一样使用多数据源，因此对SQL的访问都是在同一个逻辑schema之上。
+不支持包含真实 schema 的 SQL，但支持包含逻辑 schema 的 SQL。因为 ShardingSphere 的理念是像使用一个数据源一样使用多数据源，因此对 SQL 的访问都是在同一个逻辑 schema 之上。
 
 ### 对分片键进行操作
 
diff --git a/docs/document/content/features/sharding/use-norms/sql.en.md b/docs/document/content/features/sharding/use-norms/sql.en.md
index 8d5b77fe61..842b359641 100644
--- a/docs/document/content/features/sharding/use-norms/sql.en.md
+++ b/docs/document/content/features/sharding/use-norms/sql.en.md
@@ -56,29 +56,31 @@ Partially support CASE WHEN
 Do not support UNION (ALL) 
 
 Partly available sub-query
-* If subquery and outer query specify sharding key at the same time, the value of sharding key must be consistent.
+* Subquery is supported by kernel when sharding keys are specified in both subquery and outer query, and values of sharding keys are the same.
+* Subquery is supported by federation executor engine (under development) when sharding keys are not specified for both subquery and outer query, or values of sharding keys are not the same.
 
-Support not only pagination sub-query (see [pagination](https://shardingsphere.apache.org/document/current/cn/features/sharding/usage-standard/pagination) for more details), but also sub-query with the same mode. No matter how many layers are nested, ShardingSphere can parse to the first sub-query that contains data table. Once it finds another sub-query of this kind in the sub-level nested, it will directly throw a parsing exception.
+Support not only pagination sub-query (see [pagination](https://shardingsphere.apache.org/document/current/cn/features/sharding/usage-standard/pagination) for more details), but also sub-query with the same mode.
 
-For example, the following sub-query is available:
+For example, the following subquery is supported by kernel:
 
 ```sql
-SELECT COUNT(*) FROM (SELECT * FROM t_order) o;
-SELECT COUNT(*) FROM (SELECT * FROM t_order) o WHERE o.order_id = 1;
-SELECT COUNT(*) FROM (SELECT * FROM t_order WHERE order_id = 1) o;
-SELECT COUNT(*) FROM (SELECT * FROM t_order WHERE order_id = 1) o WHERE o.order_id = 1;
-SELECT COUNT(*) FROM (SELECT * FROM t_order WHERE product_id = 1) o;
+SELECT * FROM (SELECT * FROM t_order WHERE order_id = 1) o WHERE o.order_id = 1;
+SELECT * FROM (SELECT row_.*, rownum rownum_ FROM (SELECT * FROM t_order) row_ WHERE rownum <= ?) WHERE rownum > ?;
 ```
 
-The following sub-query is unavailable:
+The following subquery is supported by federation executor engine (under development):
 
 ```sql
-SELECT COUNT(*) FROM (SELECT * FROM t_order WHERE order_id = 1) o WHERE o.order_id = 2;
+SELECT * FROM (SELECT * FROM t_order) o;
+SELECT * FROM (SELECT * FROM t_order) o WHERE o.order_id = 1;
+SELECT * FROM (SELECT * FROM t_order WHERE order_id = 1) o;
+SELECT * FROM (SELECT * FROM t_order WHERE product_id = 1) o;
+SELECT * FROM (SELECT * FROM t_order WHERE order_id = 1) o WHERE o.order_id = 2;
 ```
 
-To be simple, through sub-query, non-functional requirements are available in most cases, such as pagination, sum count and so on; but functional requirements are unavailable for now.
+To be simple, through subquery, non-functional requirements are supported by kernel in most cases, such as pagination, sum count and so on. Functional requirements are supported by federation executor engine (under development).
 
-Do not support SQL that contains schema, for the concept of ShardingSphere is to use multiple data source as one data source, so all the SQL visits are based on one logic schema.
+Do not support SQL that contains actual schema, but support SQL that contains logic schema. For the concept of ShardingSphere is to use multiple data source as one data source, so all the SQL visits are based on one logic schema.
 
 ### Operation for shardingColumn
 
