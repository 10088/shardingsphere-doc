commit c4346426a0fa855e6c53ff5123cfc5723f615408
Author: DeviousLab <deviouslab@gmail.com>
Date:   Sat Jul 24 13:49:37 2021 +0400

    Updated CN pagination O(nlogn) (#11461)
    
    * Updated CN pagination O(nlogn)
    
    * Updated EN pagination O(nlogn)

diff --git a/docs/document/content/features/sharding/use-norms/pagination.cn.md b/docs/document/content/features/sharding/use-norms/pagination.cn.md
index b04543ed3a..4e4d437642 100644
--- a/docs/document/content/features/sharding/use-norms/pagination.cn.md
+++ b/docs/document/content/features/sharding/use-norms/pagination.cn.md
@@ -32,7 +32,7 @@ ShardingSphere进行了2个方面的优化。
 首先，采用流式处理 + 归并排序的方式来避免内存的过量占用。由于SQL改写不可避免的占用了额外的带宽，但并不会导致内存暴涨。
 与直觉不同，大多数人认为ShardingSphere会将`1,000,010 * 2`记录全部加载至内存，进而占用大量内存而导致内存溢出。
 但由于每个结果集的记录是有序的，因此ShardingSphere每次比较仅获取各个分片的当前结果集记录，驻留在内存中的记录仅为当前路由到的分片的结果集的当前游标指向而已。
-对于本身即有序的待排序对象，归并排序的时间复杂度仅为`O(n)`，性能损耗很小。
+对于本身即有序的待排序对象，归并排序的时间复杂度仅为`O(nlogn)`，性能损耗很小。
 
 其次，ShardingSphere对仅落至单分片的查询进行进一步优化。
 落至单分片查询的请求并不需要改写SQL也可以保证记录的正确性，因此在此种情况下，ShardingSphere并未进行SQL改写，从而达到节省带宽的目的。
diff --git a/docs/document/content/features/sharding/use-norms/pagination.en.md b/docs/document/content/features/sharding/use-norms/pagination.en.md
index 292791bbdb..800d0b7d7e 100644
--- a/docs/document/content/features/sharding/use-norms/pagination.en.md
+++ b/docs/document/content/features/sharding/use-norms/pagination.en.md
@@ -28,7 +28,7 @@ It also means taking out all the records prior to the offset and only acquire th
 ShardingSphere has optimized in two ways.
 
 Firstly, it adopts stream process + merger ordering to avoid excessive memory occupation. SQL rewrite unavoidably occupies extra bandwidth, but it will not lead to sharp increase of memory occupation. Most people may assume that ShardingSphere would upload all the `1,000,010 * 2` records to the memory and occupy a large amount of it, which can lead to memory overflow. But each ShardingSphere comparison only acquires current result set record of each shard, since result set records have their own order.
-The record stored in the memory is only the current position pointed by the cursor in the result set of the shard routed to. For the item to be sorted which has its own order, merger ordering only has the time complexity of `O(n)`, with a very low performance consumption.
+The record stored in the memory is only the current position pointed by the cursor in the result set of the shard routed to. For the item to be sorted which has its own order, merger ordering only has the time complexity of `O(nlogn)`, with a very low performance consumption.
 
 Secondly, ShardingSphere further optimizes the query that only falls into single shards. Requests of this kind can guarantee the correctness of records without rewriting SQLs. Under this kind of situation, ShardingSphere will not do that in order to save the bandwidth.
 
