1,3c1,3
< commit 400e32c62f2338a73623222d1f8e8a8c3bb35da5
< Author: Liang Zhang <terrymanu@163.com>
< Date:   Sun Nov 1 16:53:01 2020 +0800
---
> commit 2d6100748de7f9883413766e25b1bdbdb4d11c9a
> Author: JingShang Lu <lujingshang@apache.org>
> Date:   Tue Nov 3 14:29:39 2020 +0800
5c5,19
<     Remove format visitor desc for document (#8002)
---
>     fix doc for sql support (#7962)
>     
>     * fix doc for sql support
>     
>     * fix
>     
>     * fix
>     
>     * fix
>     
>     * fix
>     
>     * fix
>     
>     * Update sql.cn.md
7,35c21,25
< diff --git a/docs/document/content/dev-manual/sql-parser.cn.md b/docs/document/content/dev-manual/sql-parser.cn.md
< index e3c2b8cf3b..d27cf0c975 100644
< --- a/docs/document/content/dev-manual/sql-parser.cn.md
< +++ b/docs/document/content/dev-manual/sql-parser.cn.md
< @@ -32,11 +32,6 @@ chapter = true
<  | SQLServerStatementSQLVisitorFacade  | 基于 SQLServer 的提取 SQL 语句的语法树访问器   |
<  | OracleStatementSQLVisitorFacade     | 基于 Oracle 的提取 SQL 语句的语法树访问器      |
<  | SQL92StatementSQLVisitorFacade      | 基于 SQL92 的SQL 解析器入口                   |
< -| MySQLFormatSQLVisitorFacade         | 基于 MySQL 的 SQL 语句格式化的语法树访问器      |
< -| PostgreSQLFormatSQLVisitorFacade    | 基于 PostgreSQL 的 SQL 语句格式化的语法树访问器 |
< -| SQLServerFormatSQLVisitorFacade     | 基于 SQLServer 的 SQL 语句格式化的语法树访问器  |
< -| OracleFormatSQLVisitorFacade        | 基于 Oracle 的 SQL 语句格式化的语法树访问器     |
< -| SQL92FormatSQLVisitorFacade         | 基于 SQL92 的 SQL 语句格式化的语法树访问器      |
<  
<  ## ParsingHook
<  
< diff --git a/docs/document/content/dev-manual/sql-parser.en.md b/docs/document/content/dev-manual/sql-parser.en.md
< index 3485ea3cd2..793466bc7d 100644
< --- a/docs/document/content/dev-manual/sql-parser.en.md
< +++ b/docs/document/content/dev-manual/sql-parser.en.md
< @@ -32,11 +32,6 @@ chapter = true
<  | SQLServerStatementSQLVisitorFacade  | SQL visitor of statement extracted facade for SQLServer  |
<  | OracleStatementSQLVisitorFacade     | SQL visitor of statement extracted facade for Oracle     |
<  | SQL92StatementSQLVisitorFacade      | SQL visitor of statement extracted facade for SQL92      |
< -| MySQLFormatSQLVisitorFacade         | SQL visitor of SQL formatted facade for MySQL            |
< -| PostgreSQLFormatSQLVisitorFacade    | SQL visitor of SQL formatted facade for PostgreSQL       |
< -| SQLServerFormatSQLVisitorFacade     | SQL visitor of SQL formatted facade for SQLServer        |
< -| OracleFormatSQLVisitorFacade        | SQL visitor of SQL formatted for Oracle                  |
< -| SQL92FormatSQLVisitorFacade         | SQL visitor of SQL formatted for SQL92                   |
---
> diff --git a/docs/document/content/features/sharding/use-norms/sql.cn.md b/docs/document/content/features/sharding/use-norms/sql.cn.md
> index ef9de86945..7d1d4d8601 100644
> --- a/docs/document/content/features/sharding/use-norms/sql.cn.md
> +++ b/docs/document/content/features/sharding/use-norms/sql.cn.md
> @@ -49,20 +49,26 @@ tbl_name [AS] alias] [index_hint_list]
37c27
<  ## ParsingHook
---
>  ### 路由至多数据节点
38a29,88
> -不支持CASE WHEN、HAVING、UNION (ALL)，有限支持子查询。
> +部分支持CASE WHEN
> +* `CASE WHEN` 中包含子查询不支持
> +* `CASE WHEN` 中使用逻辑表名不支持（请使用表别名）
> +不支持 HAVING、UNION (ALL)
> +
> +部分支持子查询
> +* 子查询中必须包含分片键，且分片键必须和父查询中的分片键一致
>  
>  除了分页子查询的支持之外(详情请参考[分页](/cn/features/sharding/use-norms/pagination))，也支持同等模式的子查询。无论嵌套多少层，ShardingSphere都可以解析至第一个包含数据表的子查询，一旦在下层嵌套中再次找到包含数据表的子查询将直接抛出解析异常。
>  
>  例如，以下子查询可以支持：
>  
>  ```sql
> -SELECT COUNT(*) FROM (SELECT * FROM t_order o)
> +SELECT COUNT(*) FROM (SELECT * FROM t_order o where id>10) where id>10;
>  ```
>  
>  以下子查询不支持：
>  
>  ```sql
> -SELECT COUNT(*) FROM (SELECT * FROM t_order o WHERE o.id IN (SELECT id FROM t_order WHERE status = ?))
> +SELECT COUNT(*) FROM (SELECT * FROM t_order o)
>  ```
>  
>  简单来说，通过子查询进行非功能需求，在大部分情况下是可以支持的。比如分页、统计总数等；而通过子查询实现业务查询当前并不能支持。
> diff --git a/docs/document/content/features/sharding/use-norms/sql.en.md b/docs/document/content/features/sharding/use-norms/sql.en.md
> index 119f6a56ac..fc7eb13da6 100644
> --- a/docs/document/content/features/sharding/use-norms/sql.en.md
> +++ b/docs/document/content/features/sharding/use-norms/sql.en.md
> @@ -49,20 +49,26 @@ tbl_name [AS] alias] [index_hint_list]
>  
>  ### Route to multiple data nodes
>  
> -Do not support CASE WHEN, HAVING and UNION (ALL) and partly available sub-query.
> +Partially support CASE WHEN
> +* `CASE WHEN` containing sub-query is not supported
> +* `CASE WHEN` containing logical-table is not supported(please use alias of table)
> +
> +Do not support HAVING and UNION (ALL) 
> +Partly available sub-query
> +* If there is a subquery, it needs sharding key condition and be consistent with the parent query.
>  
>  Support not only pagination sub-query (see [pagination](https://shardingsphere.apache.org/document/current/cn/features/sharding/usage-standard/pagination) for more details), but also sub-query with the same mode. No matter how many layers are nested, ShardingSphere can parse to the first sub-query that contains data table. Once it finds another sub-query of this kind in the sub-level nested, it will directly throw a parsing exception.
>  
>  For example, the following sub-query is available:
>  
>  ```sql
> -SELECT COUNT(*) FROM (SELECT * FROM t_order o)
> +SELECT COUNT(*) FROM (SELECT * FROM t_order o where id>10) where id>10;
>  ```
>  
>  The following sub-query is unavailable:
>  
>  ```sql
> -SELECT COUNT(*) FROM (SELECT * FROM t_order o WHERE o.id IN (SELECT id FROM t_order WHERE status = ?))
> +SELECT COUNT(*) FROM (SELECT * FROM t_order o)
>  ```
>  
>  To be simple, through sub-query, non-functional requirements are available in most cases, such as pagination, sum count and so on; but functional requirements are unavailable for now.
