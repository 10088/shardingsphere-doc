1,3c1,3
< commit be42925d34b0fbbe799df379871bc16ba08db29b
< Author: yang-7777 <67564630+yang-7777@users.noreply.github.com>
< Date:   Tue Oct 13 10:59:53 2020 +0800
---
> commit 6866d748f0e5fb5b27dff251caf98e4773e71cef
> Author: Zhang Yonglun <zhangyonglun@apache.org>
> Date:   Tue Oct 13 15:48:43 2020 +0800
5c5
<     Update result.en.md (#7756)
---
>     #5301, use MySQL and PostgreSQL for integration test on travis (#7769)
7c7,13
<     add a pic in the summary section
---
>     * add mysql env to travis
>     
>     * add mysql env to travis
>     
>     * add postgresql env to travis
>     
>     * add ci profile
9,27c15,59
< diff --git a/docs/blog/content/material/result.en.md b/docs/blog/content/material/result.en.md
< index 71e100da8f..89fc0d753c 100644
< --- a/docs/blog/content/material/result.en.md
< +++ b/docs/blog/content/material/result.en.md
< @@ -23,12 +23,12 @@ Since the result set returned from the database is returned one by one, it is no
<  Streaming merge means that each time the data is fetched from the result set, the correct individual data can be returned by fetching it one by one, which is most compatible with the way the database returns the result set natively. Traversal, sorting, and Stream Group-by Merger are all types of stream imputation.
<  
<  In-memory merging, on the other hand, requires that all data in the result set be traversed and stored in memory, and then after unified grouping, sorting, and aggregation calculations, it is encapsulated to return the result set of data accessed one item at a time.
< +
<  The decorator merge is a unified functional enhancement of all the result set merge, currently the decorator merge only paging this type of merge.
<  
<  
<  ### Categorization
<  
< -
<  #### Iteration Merger 
<  It is the simplest form of aggregation. Simply merge multiple result sets into a one-way chain table. After iterating through the current result set in the chain table, move the chain table element back one place and continue to iterate through the next result set.
<  
< @@ -112,11 +112,13 @@ Sharding-Sphere's Pagination capabilities are rather misleading to users, who of
---
> diff --git a/docs/document/content/features/test-engine/integration-test-engine.cn.md b/docs/document/content/features/test-engine/integration-test-engine.cn.md
> index 764a0e5b44..31664fca38 100644
> --- a/docs/document/content/features/test-engine/integration-test-engine.cn.md
> +++ b/docs/document/content/features/test-engine/integration-test-engine.cn.md
> @@ -13,7 +13,7 @@ Junit 中的 `Parameterized` 会聚合起所有的测试数据，并将测试数
>  ### 配置
>  
>    - 环境类文件
> -    - /shardingsphere-test-suite/src/test/resources/integrate/env.properties
> +    - /shardingsphere-test-suite/src/test/resources/integrate/env-jdbc-local.properties
>      - /shardingsphere-test-suite/src/test/resources/integrate/env/`SQL-TYPE`/dataset.xml
>      - /shardingsphere-test-suite/src/test/resources/integrate/env/`SQL-TYPE`/schema.xml
>    - 测试用例类文件
> @@ -26,7 +26,7 @@ Junit 中的 `Parameterized` 会聚合起所有的测试数据，并将测试数
>  
>  集成测试需要真实的数据库环境，根据相应的配置文件创建测试环境：
>  
> -首先，修改配置文件 `/shardingsphere-test-suite/src/test/resources/integrate/env.properties` ，例子如下：
> +首先，修改配置文件 `/shardingsphere-test-suite/src/test/resources/integrate/env-jdbc-local.properties` ，例子如下：
>  
>  ```properties
>  # 测试主键，并发，column index等的开关
> @@ -90,7 +90,7 @@ oracle.password=jdbc
>  
>  ### 断言配置
>  
> -`env.properties` 与 `dataset.xml ` 确定了什么SQL在什么环境执行，下面是断言数据的配置：
> +`env-jdbc-local.properties` 与 `dataset.xml ` 确定了什么SQL在什么环境执行，下面是断言数据的配置：
>  
>  断言的配置，需要两种文件，第一类文件位于 `/shardingsphere-test-suite/src/test/resources/integrate/cases/SQL-TYPE/SQL-TYPE-integrate-test-cases.xml`
>  这个文件类似于一个索引，定义了要执行的SQL，参数以及期待的数据的文件位置。这里的 test-case 引用的就是`sharding-sql-test`中 SQL 对应的`sql-case-id`，例子如下：
> diff --git a/docs/document/content/features/test-engine/integration-test-engine.en.md b/docs/document/content/features/test-engine/integration-test-engine.en.md
> index 63e79ff690..b1e3438349 100644
> --- a/docs/document/content/features/test-engine/integration-test-engine.en.md
> +++ b/docs/document/content/features/test-engine/integration-test-engine.en.md
> @@ -12,7 +12,7 @@ The `Parameterized` in JUnit will collect all test data, and pass to test method
>  ### Configuration
>   
>    - environment type
> -    - /shardingsphere-test-suite/src/test/resources/integrate/env.properties
> +    - /shardingsphere-test-suite/src/test/resources/integrate/env-jdbc-local.properties
>      - /shardingsphere-test-suite/src/test/resources/integrate/env/`SQL-TYPE`/dataset.xml
>      - /shardingsphere-test-suite/src/test/resources/integrate/env/`SQL-TYPE`/schema.xml
>    - test case type
> @@ -25,7 +25,7 @@ The `Parameterized` in JUnit will collect all test data, and pass to test method
29c61
<  However, it is also important to note that a large amount of data still needs to be transferred to Sharding-Sphere's memory space due to the sorting needs. Therefore, it is not a best practice to use LIMIT for Pagination in this manner. Since LIMIT does not query data by index, Pagination by ID is a better solution if continuity of ID can be guaranteed, e.g..
---
>  Integration test depends on existed database environment, developer need to setup the configuration file for corresponding database to test: 
31,37c63,64
< -
<  ![](https://shardingsphere.apache.org/blog/img/result7.jpg)
<    
<  Or by recording the ID of the last record of the last query result for the next page, for example.
<   
< - 
<  ![](https://shardingsphere.apache.org/blog/img/result8.jpg)
---
> -Firstly, setup configuration file `/shardingsphere-test-suite/src/test/resources/integrate/env.properties`, for example: 
> +Firstly, setup configuration file `/shardingsphere-test-suite/src/test/resources/integrate/env-jdbc-local.properties`, for example: 
39,42c66,67
< +### Summary
< +
< +The whole structure of merger engine is showing below:
< +![](https://shardingsphere.apache.org/blog/img/result10.png)
---
>  ```properties
>  # the switch for PK, concurrent, column index testing and so on
