<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Job Listener on ElasticJob</title>
    <link>https://shardingsphere.apache.org/elasticjob/current/en/user-manual/elasticjob-lite/usage/job-listener/</link>
    <description>Recent content in Job Listener on ElasticJob</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://shardingsphere.apache.org/elasticjob/current/en/user-manual/elasticjob-lite/usage/job-listener/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Listener Development</title>
      <link>https://shardingsphere.apache.org/elasticjob/current/en/user-manual/elasticjob-lite/usage/job-listener/listener-interface/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/elasticjob/current/en/user-manual/elasticjob-lite/usage/job-listener/listener-interface/</guid>
      <description>Common Listener If the job processes the files of the job server and deletes the files after the processing is completed, consider using each node to perform the cleaning task. This type of task is simple to implement, and there is no need to consider whether the global distributed task is completed. You should try to use this type of listener.
public class MyJobListener implements ElasticJobListener { @Override public void beforeJobExecuted(ShardingContexts shardingContexts) { // do something .</description>
    </item>
    
    <item>
      <title>Use Java API</title>
      <link>https://shardingsphere.apache.org/elasticjob/current/en/user-manual/elasticjob-lite/usage/job-listener/java-api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/elasticjob/current/en/user-manual/elasticjob-lite/usage/job-listener/java-api/</guid>
      <description>Common Listener public class JobMain { public static void main(String[] args) { new ScheduleJobBootstrap(createRegistryCenter(), createJobConfiguration(), new MyElasticJobListener()).schedule(); } private static CoordinatorRegistryCenter createRegistryCenter() { CoordinatorRegistryCenter regCenter = new ZookeeperRegistryCenter(new ZookeeperConfiguration(&amp;#34;zk_host:2181&amp;#34;, &amp;#34;elastic-job-demo&amp;#34;)); regCenter.init(); return regCenter; } private static JobConfiguration createJobConfiguration() { // Create job configuration  ... } } Distributed Listener public class JobMain { public static void main(String[] args) { long startTimeoutMills = 5000L; long completeTimeoutMills = 10000L; new ScheduleJobBootstrap(createRegistryCenter(), createJobConfiguration(), new MyDistributeOnceElasticJobListener(startTimeoutMills, completeTimeoutMills)).</description>
    </item>
    
    <item>
      <title>Spring Boot Starter</title>
      <link>https://shardingsphere.apache.org/elasticjob/current/en/user-manual/elasticjob-lite/usage/job-listener/spring-boot-starter/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/elasticjob/current/en/user-manual/elasticjob-lite/usage/job-listener/spring-boot-starter/</guid>
      <description>TODO</description>
    </item>
    
    <item>
      <title>Spring Namespace</title>
      <link>https://shardingsphere.apache.org/elasticjob/current/en/user-manual/elasticjob-lite/usage/job-listener/spring-namespace/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://shardingsphere.apache.org/elasticjob/current/en/user-manual/elasticjob-lite/usage/job-listener/spring-namespace/</guid>
      <description>TODO</description>
    </item>
    
  </channel>
</rss>