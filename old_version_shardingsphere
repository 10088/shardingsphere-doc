commit 57e00394641b3ac28c4436096bdac9688c28158d
Author: Chuxin Chen <chuxinchen.x@qq.com>
Date:   Thu Jul 14 11:31:17 2022 +0800

    best-practice (#19125)

diff --git a/docs/document/content/best-practices/encrypt.cn.md b/docs/document/content/best-practices/encrypt.cn.md
new file mode 100644
index 00000000000..5c9e54293dd
--- /dev/null
+++ b/docs/document/content/best-practices/encrypt.cn.md
@@ -0,0 +1,68 @@
++++
+pre = "<b>7.5. </b>"
+title = "数据加密"
+weight = 5
+chapter = true
++++
+
+## 适用场景
+不论是新业务需要使用数据加密的功能，还是需要对已有业务进行改造满足加密需求，Apache ShardingSphere 都提供了一套完整的数据加密解决方案。用户可以通过如下实践进行学习了解。
+## 前提条件
+假设新业务上线，现在期望对用户的密码字段进行加密存储于数据库中，但同时系统要能够获取明文数据。
+## 数据规划
+由于用户期望对密码字段进行加密存储，但是系统又要能够获取明文字段，那么我们可以采用可逆算法 AES 对数据进行加密。因此我们可以采用如配置示例中所示的配置，对`t_user` 表进行加密，逻辑列名称为 `pwd`，也就是业务 SQL 中采用的字段名称，该字段映射到数据库中为 `pwd_cipher` 字段，对应的加密算法采用 AES。
+## 操作步骤
+1. 下载 ShardingSphere-proxy
+2. 采用如配置示例所示的加密配置
+3. 连接 proxy 后，创建 `t_user` 表
+``` sql
+## 可以通过 PREVIEW 语法查看真实创建表语法
+encrypt_db=> PREVIEW CREATE TABLE t_user (user_id INT NOT NULL, username VARCHAR(200), pwd VARCHAR(200) NOT NULL, PRIMARY KEY (user_id));
+ data_source_name |                                                         actual_sql
+------------------+----------------------------------------------------------------------------------------------------------------------------
+ ds_0             | CREATE TABLE t_user (user_id INT NOT NULL, username VARCHAR(200), pwd_cipher VARCHAR(200) NOT NULL, PRIMARY KEY (user_id))
+(1 row)
+CREATE TABLE t_user (user_id INT NOT NULL, username VARCHAR(200), pwd VARCHAR(200) NOT NULL, PRIMARY KEY (user_id));
+``` 
+4. 向 `t_user` 表中插入数据
+``` sql
+encrypt_db=> PREVIEW INSERT INTO t_user values (1,'ZHANGSAN','123456');
+ data_source_name |                                              actual_sql
+------------------+------------------------------------------------------------------------------------------------------
+ ds_0             | INSERT INTO t_user(user_id, username, pwd_cipher) values (1, 'ZHANGSAN', 'MyOShk4kjRnds7CZfU5NCw==')
+(1 row)
+INSERT INTO t_user values (1,'ZHANGSAN','123456');
+```
+5. 查询 `t_user` 表
+``` sql
+encrypt_db=> PREVIEW SELECT * FROM t_user WHERE pwd = '123456';
+ data_source_name |                                                                actual_sql
+------------------+------------------------------------------------------------------------------------------------------------------------------------------
+ ds_0             | SELECT "t_user"."user_id", "t_user"."username", "t_user"."pwd_cipher" AS "pwd" FROM t_user WHERE pwd_cipher = 'MyOShk4kjRnds7CZfU5NCw=='
+(1 row)
+encrypt_db=> SELECT * FROM t_user WHERE pwd = '123456';
+ user_id | username |  pwd
+---------+----------+--------
+       1 | ZHANGSAN | 123456
+(1 row)
+```
+
+## 配置示例
+config-encrypt.yaml
+``` yaml
+rules:
+- !ENCRYPT
+  encryptors:
+    aes_encryptor:
+      type: AES
+      props:
+        aes-key-value: 123456abc
+  tables:
+    t_user:
+      columns:
+        pwd:
+          cipherColumn: pwd_cipher
+          encryptorName: aes_encryptor
+```
+## 相关参考
+[YAML 配置：数据加密](/cn/user-manual/shardingsphere-jdbc/yaml-config/rules/encrypt/)
\ No newline at end of file
diff --git a/docs/document/content/best-practices/encrypt.en.md b/docs/document/content/best-practices/encrypt.en.md
new file mode 100644
index 00000000000..cc3e4e2853d
--- /dev/null
+++ b/docs/document/content/best-practices/encrypt.en.md
@@ -0,0 +1,69 @@
++++
+pre = "<b>7.5. </b>"
+title = "Encryption"
+weight = 5
+chapter = true
++++
+
+## Scenarios
+Whether a new business needs to use data encryption capabilities, or an existing business needs to be transformed to meet encryption needs, Apache ShardingSphere provides a complete set of data encryption solutions.
+## Prerequisites
+Assuming that the new service goes online, it is now expected that the user's password field will be encrypted and stored in the database, but at the same time, the system should be able to obtain plaintext data.
+## Data Planning
+Since the user expects the password field to be stored encrypted, but the system needs to be able to obtain the plaintext field, we can encrypt the data using the reversible algorithm AES.
+So we can encrypt the `t_user` table with the logical column name `pwd`, which is the field name in Business SQL, which maps to the 'pwd_cipher' field in the database, corresponding to AES, using the configuration shown in the configuration example.
+## Procedure
+1. Download ShardingSphere-proxy.
+2. Use the encryption configuration shown in the configuration example.
+3. After the proxy is connected, create the `t_user` table.
+``` sql
+## You can view the real creation table syntax through the PREVIEW syntax.
+encrypt_db=> PREVIEW CREATE TABLE t_user (user_id INT NOT NULL, username VARCHAR(200), pwd VARCHAR(200) NOT NULL, PRIMARY KEY (user_id));
+ data_source_name |                                                         actual_sql
+------------------+----------------------------------------------------------------------------------------------------------------------------
+ ds_0             | CREATE TABLE t_user (user_id INT NOT NULL, username VARCHAR(200), pwd_cipher VARCHAR(200) NOT NULL, PRIMARY KEY (user_id))
+(1 row)
+CREATE TABLE t_user (user_id INT NOT NULL, username VARCHAR(200), pwd VARCHAR(200) NOT NULL, PRIMARY KEY (user_id));
+``` 
+4. Insert data into the `t_user` table.
+``` sql
+encrypt_db=> PREVIEW INSERT INTO t_user values (1,'ZHANGSAN','123456');
+ data_source_name |                                              actual_sql
+------------------+------------------------------------------------------------------------------------------------------
+ ds_0             | INSERT INTO t_user(user_id, username, pwd_cipher) values (1, 'ZHANGSAN', 'MyOShk4kjRnds7CZfU5NCw==')
+(1 row)
+INSERT INTO t_user values (1,'ZHANGSAN','123456');
+```
+5. Query `t_user` table.
+``` sql
+encrypt_db=> PREVIEW SELECT * FROM t_user WHERE pwd = '123456';
+ data_source_name |                                                                actual_sql
+------------------+------------------------------------------------------------------------------------------------------------------------------------------
+ ds_0             | SELECT "t_user"."user_id", "t_user"."username", "t_user"."pwd_cipher" AS "pwd" FROM t_user WHERE pwd_cipher = 'MyOShk4kjRnds7CZfU5NCw=='
+(1 row)
+encrypt_db=> SELECT * FROM t_user WHERE pwd = '123456';
+ user_id | username |  pwd
+---------+----------+--------
+       1 | ZHANGSAN | 123456
+(1 row)
+```
+
+## Sample
+config-encrypt.yaml
+``` yaml
+rules:
+- !ENCRYPT
+  encryptors:
+    aes_encryptor:
+      type: AES
+      props:
+        aes-key-value: 123456abc
+  tables:
+    t_user:
+      columns:
+        pwd:
+          cipherColumn: pwd_cipher
+          encryptorName: aes_encryptor
+```
+## Related References
+[YAML Configuration: Encryption](/en/user-manual/shardingsphere-jdbc/yaml-config/rules/encrypt/)
\ No newline at end of file
diff --git a/docs/document/content/best-practices/readwrite-splitting.cn.md b/docs/document/content/best-practices/readwrite-splitting.cn.md
new file mode 100644
index 00000000000..6db06339327
--- /dev/null
+++ b/docs/document/content/best-practices/readwrite-splitting.cn.md
@@ -0,0 +1,74 @@
++++
+pre = "<b>7.3. </b>"
+title = "读写分离"
+weight = 3
+chapter = true
++++
+
+## 适用场景
+适用于一主多从的数据库架构，主库负责数据的写入、修改、删除等事务性操作，从库负责查询操作。
+另外 Apache ShardingSphere 的读写分离功能提供了多种负载均衡策略。
+## 前提条件
+假设用户有一主二从的数据库架构，另外用户期望两个从库能够承担不同比重的负载。
+## 数据规划
+我们将采用读写分离配置，并且针对两个从库采用 `WEIGHT` 的负载均衡策略，让两个从库承担不同的负载。
+## 操作步骤
+1. 下载 ShardingSphere-proxy
+2. 采用如配置示例所示的读写分离配置
+3. 连接 proxy 后，创建 `t_order` 表
+``` sql
+## 可以通过 PREVIEW 语法查看真实创建表语法，可以看到路由结果都是指向了 write_ds
+readwrite_splitting_db=> PREVIEW CREATE TABLE t_order (order_id INT NOT NULL, user_id INT NOT NULL, status VARCHAR(45) NULL, PRIMARY KEY (order_id));
+ data_source_name |                                                     actual_sql
+------------------+---------------------------------------------------------------------------------------------------------------------
+ write_ds         | CREATE TABLE t_order (order_id INT NOT NULL, user_id INT NOT NULL, status VARCHAR(45) NULL, PRIMARY KEY (order_id))
+(1 row)
+CREATE TABLE t_order (order_id INT NOT NULL, user_id INT NOT NULL, status VARCHAR(45) NULL, PRIMARY KEY (order_id));
+``` 
+4. 向 `t_order` 表中插入数据
+``` sql
+readwrite_splitting_db=> PREVIEW INSERT INTO t_order values (1, 1,'OK');
+ data_source_name |               actual_sql
+------------------+----------------------------------------
+ write_ds         | INSERT INTO t_order values (1, 1,'OK')
+(1 row)
+INSERT INTO t_order values (1, 1,'OK')
+```
+5. 查询 `t_order` 表
+``` sql
+## 多次查询路由到不同从库
+readwrite_splitting_db=> PREVIEW SELECT * FROM t_order;
+ data_source_name |      actual_sql
+------------------+-----------------------
+ read_ds_1        | SELECT * FROM t_order
+(1 row)
+
+readwrite_splitting_db=> PREVIEW SELECT * FROM t_order;
+ data_source_name |      actual_sql
+------------------+-----------------------
+ read_ds_0        | SELECT * FROM t_order
+(1 row)
+```
+
+## 配置示例
+config-encrypt.yaml
+```yaml
+rules:
+- !READWRITE_SPLITTING
+  dataSources:
+    readwrite_ds:
+      staticStrategy:
+        writeDataSourceName: write_ds
+        readDataSourceNames:
+          - read_ds_0
+          - read_ds_1
+      loadBalancerName: weight_lb
+  loadBalancers:
+    weight_lb:
+      type: WEIGHT
+      props:
+        read_ds_0: 2
+        read_ds_1: 1
+```
+## 相关参考
+[YAML 配置：读写分离](/cn/user-manual/shardingsphere-jdbc/yaml-config/rules/readwrite-splitting/)
\ No newline at end of file
diff --git a/docs/document/content/best-practices/readwrite-splitting.en.md b/docs/document/content/best-practices/readwrite-splitting.en.md
new file mode 100644
index 00000000000..34dccb1f779
--- /dev/null
+++ b/docs/document/content/best-practices/readwrite-splitting.en.md
@@ -0,0 +1,74 @@
++++
+pre = "<b>7.3. </b>"
+title = "Readwrite-splitting"
+weight = 3
+chapter = true
++++
+
+## Scenarios
+Suitable for a one-primary and multi-secondary database architecture. The primary database is responsible for transactional operations such as writing, modifying, and deleting data, and the secondary database is responsible for query operations.
+Apache ShardingSphere's read/write splitting feature provides a variety of load balancing strategies.
+## Prerequisites
+Suppose the user has a database architecture of one primary and two secondary databases, and the user expects the two secondary databases to be able to bear different proportions of load.
+## Data Planning
+We will adopt a read/write splitting configuration and a load balancing strategy of `WEIGHT` for both secondary databases, so that the two secondary databases bear different loads.
+## Procedure
+1. Download ShardingSphere-proxy.
+2. Use the read/write splitting configuration shown in the configuration example.
+3. After the proxy is connected, create the `t_order` table.
+``` sql
+## You can view the actual creation table syntax through the PREVIEW syntax, and you can see that the routing results all point to the write_ds
+readwrite_splitting_db=> PREVIEW CREATE TABLE t_order (order_id INT NOT NULL, user_id INT NOT NULL, status VARCHAR(45) NULL, PRIMARY KEY (order_id));
+ data_source_name |                                                     actual_sql
+------------------+---------------------------------------------------------------------------------------------------------------------
+ write_ds         | CREATE TABLE t_order (order_id INT NOT NULL, user_id INT NOT NULL, status VARCHAR(45) NULL, PRIMARY KEY (order_id))
+(1 row)
+CREATE TABLE t_order (order_id INT NOT NULL, user_id INT NOT NULL, status VARCHAR(45) NULL, PRIMARY KEY (order_id));
+``` 
+4. Inserts data into the `t_order` table.
+``` sql
+readwrite_splitting_db=> PREVIEW INSERT INTO t_order values (1, 1,'OK');
+ data_source_name |               actual_sql
+------------------+----------------------------------------
+ write_ds         | INSERT INTO t_order values (1, 1,'OK')
+(1 row)
+INSERT INTO t_order values (1, 1,'OK')
+```
+5. Query `t_order` table.
+``` sql
+## Multiple queries are routed to different secondary databases.
+readwrite_splitting_db=> PREVIEW SELECT * FROM t_order;
+ data_source_name |      actual_sql
+------------------+-----------------------
+ read_ds_1        | SELECT * FROM t_order
+(1 row)
+
+readwrite_splitting_db=> PREVIEW SELECT * FROM t_order;
+ data_source_name |      actual_sql
+------------------+-----------------------
+ read_ds_0        | SELECT * FROM t_order
+(1 row)
+```
+
+## Sample
+config-encrypt.yaml
+```yaml
+rules:
+- !READWRITE_SPLITTING
+  dataSources:
+    readwrite_ds:
+      staticStrategy:
+        writeDataSourceName: write_ds
+        readDataSourceNames:
+          - read_ds_0
+          - read_ds_1
+      loadBalancerName: weight_lb
+  loadBalancers:
+    weight_lb:
+      type: WEIGHT
+      props:
+        read_ds_0: 2
+        read_ds_1: 1
+```
+## Related References
+[YAML Configuration: Readwrite-splitting](/en/user-manual/shardingsphere-jdbc/yaml-config/rules/readwrite-splitting/)
\ No newline at end of file
diff --git a/docs/document/content/best-practices/sharding.cn.md b/docs/document/content/best-practices/sharding.cn.md
new file mode 100644
index 00000000000..6e59470772e
--- /dev/null
+++ b/docs/document/content/best-practices/sharding.cn.md
@@ -0,0 +1,83 @@
++++
+pre = "<b>7.1. </b>"
+title = "数据分片"
+weight = 1
+chapter = true
++++
+
+## 适用场景
+适用于将单一节点的数据水平拆分存储至多个数据节点，并且期望业务 SQL 不做改造，依然可以针对单一存储节点书写的场景。
+## 前提条件
+假设用户期望对 `t_order` 表进行水平拆分至两个数据库实例共 4 张表，并且要求拆分后 SQL 依然针对 `t_order` 表书写。
+## 数据规划
+我们计划按照 `user_id % 2` 进行分库， `order_id % 2` 进行分表。
+## 操作步骤
+1. 下载 ShardingSphere-proxy
+2. 按照配置示例所示，配置 proxy 的分片功能，然后启动 proxy。
+3. 连接 proxy 后，创建 `t_order` 表
+``` sql
+## 可以通过 PREVIEW 语法查看真实创建表语法
+sharding_db=> PREVIEW CREATE TABLE t_order (order_id INT NOT NULL, user_id INT NOT NULL, status VARCHAR(45) NULL, PRIMARY KEY (order_id));
+ data_source_name |                                                      actual_sql
+------------------+-----------------------------------------------------------------------------------------------------------------------
+ ds_1             | CREATE TABLE t_order_0 (order_id INT NOT NULL, user_id INT NOT NULL, status VARCHAR(45) NULL, PRIMARY KEY (order_id))
+ ds_1             | CREATE TABLE t_order_1 (order_id INT NOT NULL, user_id INT NOT NULL, status VARCHAR(45) NULL, PRIMARY KEY (order_id))
+ ds_0             | CREATE TABLE t_order_0 (order_id INT NOT NULL, user_id INT NOT NULL, status VARCHAR(45) NULL, PRIMARY KEY (order_id))
+ ds_0             | CREATE TABLE t_order_1 (order_id INT NOT NULL, user_id INT NOT NULL, status VARCHAR(45) NULL, PRIMARY KEY (order_id))
+(4 rows)
+CREATE TABLE t_order (order_id INT NOT NULL, user_id INT NOT NULL, status VARCHAR(45) NULL, PRIMARY KEY (order_id));
+``` 
+4. 向 `t_order` 表中插入数据
+``` sql
+sharding_db=> PREVIEW INSERT INTO t_order values (1, 1,'OK'),(2, 2, 'OK');
+ data_source_name |                actual_sql
+------------------+-------------------------------------------
+ ds_1             | INSERT INTO t_order_1 values (1, 1, 'OK')
+ ds_0             | INSERT INTO t_order_0 values (2, 2, 'OK')
+(2 rows)
+INSERT INTO t_order values (1, 1,'OK'),(2, 2, 'OK');
+```
+5. 查询 `t_order` 表
+``` sql
+sharding_db=> PREVIEW SELECT * FROM t_order;
+ data_source_name |                        actual_sql
+------------------+-----------------------------------------------------------
+ ds_0             | SELECT * FROM t_order_0 UNION ALL SELECT * FROM t_order_1
+ ds_1             | SELECT * FROM t_order_0 UNION ALL SELECT * FROM t_order_1
+(2 rows)
+
+sharding_db=> PREVIEW SELECT * FROM t_order WHERE user_id = 1 and order_id = 1;
+ data_source_name |                         actual_sql
+------------------+------------------------------------------------------------
+ ds_1             | SELECT * FROM t_order_1 WHERE user_id = 1 and order_id = 1
+(1 row)
+```
+## 配置示例
+config-sharding.yaml
+``` yaml
+rules:
+  - !SHARDING
+    tables:
+      t_order:
+        actualDataNodes: ds_${0..1}.t_order_${0..1}
+        databaseStrategy:
+          standard:
+            shardingColumn: user_id
+            shardingAlgorithmName: database_inline
+        tableStrategy:
+          standard:
+            shardingColumn: order_id
+            shardingAlgorithmName: table_inline
+
+    shardingAlgorithms:
+      database_inline:
+        type: INLINE
+        props:
+          algorithm-expression: ds_${user_id % 2}
+      table_inline:
+        type: INLINE
+        props:
+          algorithm-expression: t_order_${order_id % 2}
+```
+## 相关参考
+[YAML 配置：数据分片](/cn/user-manual/shardingsphere-jdbc/yaml-config/rules/sharding/)
\ No newline at end of file
diff --git a/docs/document/content/best-practices/sharding.en.md b/docs/document/content/best-practices/sharding.en.md
new file mode 100644
index 00000000000..df63ff1ebd6
--- /dev/null
+++ b/docs/document/content/best-practices/sharding.en.md
@@ -0,0 +1,83 @@
++++
+pre = "<b>7.1. </b>"
+title = "Sharding"
+weight = 1
+chapter = true
++++
+
+## Scenarios
+Suitable for scenarios where the data level of a single node is split and stored in multiple data nodes, and it is expected that business SQL can still be written for a single storage node without modification.
+## Prerequisites
+Suppose you expect a horizontal split of the `t_order` table to a total of 4 tables in two DB instances, and you are required to write SQL against the `t_order` table after the split.
+## Data Planning
+We plan to divide the database according to `user_id % 2` and `order_id % 2` for the table.
+## Procedure
+1. Download ShardingSphere-proxy.
+2. Configure the sharding feature of the proxy as shown in the configuration example, and then start the proxy.
+3. After the proxy is connected, create the `t_order` table.
+``` sql
+## You can view the real creation table syntax through the PREVIEW syntax
+sharding_db=> PREVIEW CREATE TABLE t_order (order_id INT NOT NULL, user_id INT NOT NULL, status VARCHAR(45) NULL, PRIMARY KEY (order_id));
+ data_source_name |                                                      actual_sql
+------------------+-----------------------------------------------------------------------------------------------------------------------
+ ds_1             | CREATE TABLE t_order_0 (order_id INT NOT NULL, user_id INT NOT NULL, status VARCHAR(45) NULL, PRIMARY KEY (order_id))
+ ds_1             | CREATE TABLE t_order_1 (order_id INT NOT NULL, user_id INT NOT NULL, status VARCHAR(45) NULL, PRIMARY KEY (order_id))
+ ds_0             | CREATE TABLE t_order_0 (order_id INT NOT NULL, user_id INT NOT NULL, status VARCHAR(45) NULL, PRIMARY KEY (order_id))
+ ds_0             | CREATE TABLE t_order_1 (order_id INT NOT NULL, user_id INT NOT NULL, status VARCHAR(45) NULL, PRIMARY KEY (order_id))
+(4 rows)
+CREATE TABLE t_order (order_id INT NOT NULL, user_id INT NOT NULL, status VARCHAR(45) NULL, PRIMARY KEY (order_id));
+``` 
+4. Inserts data into the `t_order` table.
+``` sql
+sharding_db=> PREVIEW INSERT INTO t_order values (1, 1,'OK'),(2, 2, 'OK');
+ data_source_name |                actual_sql
+------------------+-------------------------------------------
+ ds_1             | INSERT INTO t_order_1 values (1, 1, 'OK')
+ ds_0             | INSERT INTO t_order_0 values (2, 2, 'OK')
+(2 rows)
+INSERT INTO t_order values (1, 1,'OK'),(2, 2, 'OK');
+```
+5. Query `t_order` table.
+``` sql
+sharding_db=> PREVIEW SELECT * FROM t_order;
+ data_source_name |                        actual_sql
+------------------+-----------------------------------------------------------
+ ds_0             | SELECT * FROM t_order_0 UNION ALL SELECT * FROM t_order_1
+ ds_1             | SELECT * FROM t_order_0 UNION ALL SELECT * FROM t_order_1
+(2 rows)
+
+sharding_db=> PREVIEW SELECT * FROM t_order WHERE user_id = 1 and order_id = 1;
+ data_source_name |                         actual_sql
+------------------+------------------------------------------------------------
+ ds_1             | SELECT * FROM t_order_1 WHERE user_id = 1 and order_id = 1
+(1 row)
+```
+# Sample
+config-sharding.yaml
+``` yaml
+rules:
+  - !SHARDING
+    tables:
+      t_order:
+        actualDataNodes: ds_${0..1}.t_order_${0..1}
+        databaseStrategy:
+          standard:
+            shardingColumn: user_id
+            shardingAlgorithmName: database_inline
+        tableStrategy:
+          standard:
+            shardingColumn: order_id
+            shardingAlgorithmName: table_inline
+
+    shardingAlgorithms:
+      database_inline:
+        type: INLINE
+        props:
+          algorithm-expression: ds_${user_id % 2}
+      table_inline:
+        type: INLINE
+        props:
+          algorithm-expression: t_order_${order_id % 2}
+```
+## Related References
+[YAML Configuration: Sharding](/en/user-manual/shardingsphere-jdbc/yaml-config/rules/sharding/)
\ No newline at end of file
diff --git a/docs/document/content/dev-manual/readwrite-splitting.cn.md b/docs/document/content/dev-manual/readwrite-splitting.cn.md
index 31768dcbf03..8dfe1fb6a00 100644
--- a/docs/document/content/dev-manual/readwrite-splitting.cn.md
+++ b/docs/document/content/dev-manual/readwrite-splitting.cn.md
@@ -22,3 +22,10 @@ chapter = true
 | RoundRobinReplicaLoadBalanceAlgorithm     | 基于轮询的读库负载均衡算法 |
 | RandomReplicaLoadBalanceAlgorithm         | 基于随机的读库负载均衡算法 |
 | WeightReplicaLoadBalanceAlgorithm         | 基于权重的读库负载均衡算法 |
+| TransactionRandomReplicaLoadBalanceAlgorithm     | 无论是否在事务中，读请求采用随机策略路由到多个读库 |
+| TransactionRoundRobinReplicaLoadBalanceAlgorithm | 无论是否在事务中，读请求采用轮询策略路由到多个读库 |
+| TransactionWeightReplicaLoadBalanceAlgorithm     | 无论是否在事务中，读请求采用权重策略路由到多个读库 |
+| FixedReplicaRandomLoadBalanceAlgorithm           | 显示开启事务，读请求采用随机策略路由到一个固定读库；不开事务，每次读流量使用指定算法路由到不同的读库 |
+| FixedReplicaRoundRobinLoadBalanceAlgorithm       | 显示开启事务，读请求采用轮询策略路由到一个固定读库；不开事务，每次读流量使用指定算法路由到不同的读库 |
+| FixedReplicaWeightLoadBalanceAlgorithm           | 显示开启事务，读请求采用权重策略路由到多个读库；不开事务，每次读流量使用指定算法路由到不同的读库 |
+| FixedPrimaryLoadBalanceAlgorithm                 | 读请求全部路由到主库 |
\ No newline at end of file
diff --git a/docs/document/content/dev-manual/readwrite-splitting.en.md b/docs/document/content/dev-manual/readwrite-splitting.en.md
index ae3411e1c08..287121fb6d0 100644
--- a/docs/document/content/dev-manual/readwrite-splitting.en.md
+++ b/docs/document/content/dev-manual/readwrite-splitting.en.md
@@ -22,3 +22,10 @@ chapter = true
 | RoundRobinReplicaLoadBalanceAlgorithm     | the read database load balancer algorithm based on polling |
 | RandomReplicaLoadBalanceAlgorithm         | the read database load balancer algorithm based on random |
 | WeightReplicaLoadBalanceAlgorithm         | the read database load balancer algorithm based on weight |
+| TransactionRandomReplicaLoadBalanceAlgorithm     | Whether in a transaction or not, read requests are routed to multiple replicas using a random strategy |
+| TransactionRoundRobinReplicaLoadBalanceAlgorithm | Whether in a transaction or not, read requests are routed to multiple replicas using a round-robin strategy |
+| TransactionWeightReplicaLoadBalanceAlgorithm     | Whether in a transaction or not, read requests are routed to multiple replicas using a weight strategy |
+| FixedReplicaRandomLoadBalanceAlgorithm           | Open transaction, and the read request is routed to a fixed replica using a random strategy; if the transaction is not opened, each read traffic is routed to a different replica using the specified algorithm |
+| FixedReplicaRoundRobinLoadBalanceAlgorithm       | Open transaction, and the read request is routed to a fixed replica using a round-robin strategy; if the transaction is not opened, each read traffic is routed to a different replica using the specified algorithm |
+| FixedReplicaWeightLoadBalanceAlgorithm           | Open transaction, and the read request is routed to a fixed replica using a weight strategy; if the transaction is not opened, each read traffic is routed to a different replica using the specified algorithm |
+| FixedPrimaryLoadBalanceAlgorithm                 | All read traffic is routed to the primary |
