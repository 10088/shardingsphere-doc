commit f4742d1b396c64ba09f59b6bf5ad774d7c45b242
Author: Zhengqiang Duan <duanzhengqiang@apache.org>
Date:   Thu Dec 2 14:03:53 2021 +0800

    optimize binding table route logic (#13892)
    
    * optimize binding table route logic
    
    * fix rewrite test
    
    * update binding table doc
    
    * refactor unit test

diff --git a/docs/document/content/features/sharding/concept/table.cn.md b/docs/document/content/features/sharding/concept/table.cn.md
index ae1337afd9..f0c86393c0 100644
--- a/docs/document/content/features/sharding/concept/table.cn.md
+++ b/docs/document/content/features/sharding/concept/table.cn.md
@@ -19,7 +19,8 @@ Apache ShardingSphere 通过提供多样化的表类型，适配不同场景下
 ## 绑定表
 
 指分片规则一致的主表和子表。
-例如：`t_order` 表和 `t_order_item` 表，均按照 `order_id` 分片，则此两张表互为绑定表关系。
+使用绑定表进行多表关联查询时，必须使用分片键进行关联，否则会出现笛卡尔积关联或跨库关联，从而影响查询效率。
+例如：`t_order` 表和 `t_order_item` 表，均按照 `order_id` 分片，并且使用 `order_id` 进行关联，则此两张表互为绑定表关系。
 绑定表之间的多表关联查询不会出现笛卡尔积关联，关联查询效率将大大提升。
 举例说明，如果 SQL 为：
 
@@ -39,7 +40,7 @@ SELECT i.* FROM t_order_1 o JOIN t_order_item_0 i ON o.order_id=i.order_id WHERE
 SELECT i.* FROM t_order_1 o JOIN t_order_item_1 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);
 ```
 
-在配置绑定表关系后，路由的 SQL 应该为 2 条：
+在配置绑定表关系，并且使用 `order_id` 进行关联后，路由的 SQL 应该为 2 条：
 
 ```sql
 SELECT i.* FROM t_order_0 o JOIN t_order_item_0 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);
diff --git a/docs/document/content/features/sharding/concept/table.en.md b/docs/document/content/features/sharding/concept/table.en.md
index 406cb242dd..7357d703dd 100644
--- a/docs/document/content/features/sharding/concept/table.en.md
+++ b/docs/document/content/features/sharding/concept/table.en.md
@@ -18,7 +18,8 @@ The physical table that really exists in the horizontal sharding database, i.e.,
 ## Binding Table
 
 It refers to the primary table and the joiner table with the same sharding rules.
-for example, `t_order` and `t_order_item` are both sharded by `order_id`, so they are binding tables with each other. 
+When using binding tables in multi-table correlating query, you must use the sharding key for correlation, otherwise Cartesian product correlation or cross-database correlation will appear, which will affect query efficiency.
+For example, `t_order` and `t_order_item` are both sharded by `order_id`, and use `order_id` to correlate, so they are binding tables with each other. 
 Cartesian product correlation will not appear in the multi-tables correlating query, so the query efficiency will increase greatly.
 Take this one for example, if SQL is:
 
@@ -38,7 +39,7 @@ SELECT i.* FROM t_order_1 o JOIN t_order_item_0 i ON o.order_id=i.order_id WHERE
 SELECT i.* FROM t_order_1 o JOIN t_order_item_1 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);
 ```
 
-With binding table configuration, there should be 2 SQLs after routing:
+With binding table configuration and use `order_id` to correlate, there should be 2 SQLs after routing:
 
 ```sql
 SELECT i.* FROM t_order_0 o JOIN t_order_item_0 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);
