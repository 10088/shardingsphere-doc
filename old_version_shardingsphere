commit 74f334fc9c7b1b4d811b3b35d372812486db4c0d
Author: Liang Zhang <terrymanu@163.com>
Date:   Fri Oct 29 19:42:39 2021 +0800

    Update SQL norms (#13357)

diff --git a/docs/document/content/features/sharding/use-norms/sql.cn.md b/docs/document/content/features/sharding/use-norms/sql.cn.md
index 661a836ff3..adbf70ea58 100644
--- a/docs/document/content/features/sharding/use-norms/sql.cn.md
+++ b/docs/document/content/features/sharding/use-norms/sql.cn.md
@@ -3,47 +3,49 @@ title = "SQL"
 weight = 1
 +++
 
-由于SQL语法灵活复杂，分布式数据库和单机数据库的查询场景又不完全相同，难免有和单机数据库不兼容的SQL出现。
+由于 SQL 语法灵活复杂，面向分布式的数据库和单机数据库的查询场景又不完全相同，难免有和单机数据库不兼容的 SQL 出现。
 
-本文详细罗列出已明确可支持的SQL种类以及已明确不支持的SQL种类，尽量让使用者避免踩坑。
+本文详细罗列出已明确可支持的 SQL 种类以及已明确不支持的 SQL 种类，供使用者参考。
 
-其中必然有未涉及到的SQL欢迎补充，未支持的SQL也尽量会在未来的版本中支持。
+其中有未涉及到的 SQL 欢迎补充，未支持的 SQL 也尽量会在未来的版本中支持。
 
 ## 解析引擎
 
-解析引擎由 `SQLParser` 和 `SQLVisitor` 组成。 `SQLParser` 负责将 SQL 解析为语法树。 `SQLVisitor` 负责将语法树转化为 `SQLStatement`。目前解析引擎支持 MySQL, PostgreSQL, SQLServer, Oracle, openGauss 以及符合 SQL92 规范的 SQL 语句。不过由于 SQL 语法的复杂性，目前仍然存在少量解析引擎不支持的 SQL，清单如下：
-
-### 不支持项
-#### MySQL
-
-| SQL                                                                                        | 
-| ------------------------------------------------------------------------------------------ |
-| FLUSH PRIVILEGES                                                                           | 
-| CLONE LOCAL DATA DIRECTORY = 'clone_dir'                                                   | 
-| INSTALL COMPONENT 'file://component1', 'file://component2'                                 | 
-| UNINSTALL COMPONENT 'file://component1', 'file://component2'                               | 
-| SHOW CREATE USER user                                                                      | 
-| REPAIR TABLE t_order                                                                       | 
-| OPTIMIZE TABLE t_order                                                                     | 
-| CHECKSUM TABLE t_order                                                                     | 
-| CHECK TABLE t_order                                                                        | 
-| SET RESOURCE GROUP group_name                                                              | 
-| DROP RESOURCE GROUP group_name                                                             | 
-| CREATE RESOURCE GROUP group_name TYPE = SYSTEM                                             | 
-| ALTER RESOURCE GROUP rg1 VCPU = 0-63                                                       | 
+解析引擎负责将 SQL 字符串解析为抽象语法树。
+目前支持 MySQL, PostgreSQL, SQLServer, Oracle, openGauss 以及符合 SQL92 规范的 SQL。
+由于 SQL 语法的复杂性，目前仍然存在少量解析引擎不支持的 SQL。
+
+清单如下：
+
+| MySQL                                                        |
+| ------------------------------------------------------------ |
+| FLUSH PRIVILEGES                                             |
+| CLONE LOCAL DATA DIRECTORY = 'clone_dir'                     |
+| INSTALL COMPONENT 'file://component1', 'file://component2'   |
+| UNINSTALL COMPONENT 'file://component1', 'file://component2' |
+| SHOW CREATE USER user                                        |
+| REPAIR TABLE t_order                                         |
+| OPTIMIZE TABLE t_order                                       |
+| CHECKSUM TABLE t_order                                       |
+| CHECK TABLE t_order                                          |
+| SET RESOURCE GROUP group_name                                |
+| DROP RESOURCE GROUP group_name                               |
+| CREATE RESOURCE GROUP group_name TYPE = SYSTEM               |
+| ALTER RESOURCE GROUP rg1 VCPU = 0-63                         |
 
 ## 数据分片
-### 支持项
 
-#### 路由至单数据节点
+兼容全部常用的**路由至单数据节点**的 SQL；
+**路由至多数据节点**的 SQL 由于场景复杂，分为稳定支持、实验性支持和不支持这三种情况。
 
-- 100%全兼容（目前仅MySQL，其他数据库完善中）。
+### 稳定支持
 
-#### 路由至多数据节点
+全面支持 DML、DDL、DCL、TCL 和常用 DAL。
+支持分页、去重、排序、分组、聚合、表关联等复杂查询。
 
-全面支持DML、DDL、DCL、TCL和部分DAL。支持分页、去重、排序、分组、聚合、关联查询。以下用最为复杂的DML举例：
+#### 常规查询
 
-- SELECT主语句
+- SELECT 主语句
 
 ```sql
 SELECT select_expr [, select_expr ...] FROM table_reference [, table_reference ...]
@@ -69,124 +71,121 @@ tbl_name [AS] alias] [index_hint_list]
 | table_reference ([INNER] | {LEFT|RIGHT} [OUTER]) JOIN table_factor [JOIN ON conditional_expr | USING (column_list)]
 ```
 
-### 不支持项
+#### 子查询
 
-#### 路由至多数据节点
+子查询和外层查询同时指定分片键，且分片键的值保持一致时，由内核提供稳定支持。
 
-部分支持CASE WHEN
-* `CASE WHEN` 中包含子查询不支持
-* `CASE WHEN` 中使用逻辑表名不支持（请使用表别名）
+例如：
 
-部分支持 UNION (ALL)
-* 查询中包含分片表和广播表的 SQL 语句不支持
-
-部分支持子查询
-* 子查询和外层查询同时指定分片键，且分片键的值保持一致时，子查询由内核支持
-* 子查询和外层查询未同时指定分片键，或分片键的值不一致时，子查询由 Federation 执行引擎（开发中）支持
+```sql
+SELECT * FROM (SELECT * FROM t_order WHERE order_id = 1) o WHERE o.order_id = 1;
+```
 
-除了分页子查询的支持之外(详情请参考[分页](/cn/features/sharding/use-norms/pagination))，也支持同等模式的子查询。
+用于[分页](/cn/features/sharding/use-norms/pagination)的子查询，由内核提供稳定支持。
 
-例如，以下子查询可以由内核支持：
+例如：
 
 ```sql
-SELECT * FROM (SELECT * FROM t_order WHERE order_id = 1) o WHERE o.order_id = 1;
 SELECT * FROM (SELECT row_.*, rownum rownum_ FROM (SELECT * FROM t_order) row_ WHERE rownum <= ?) WHERE rownum > ?;
 ```
 
-以下子查询可以由 Federation 执行引擎（开发中）支持：
+#### 运算表达式中包含分片键
+
+当分片键处于运算表达式中时，无法通过 SQL `字面`提取用于分片的值，将导致全路由。
+
+例如，假设 `create_time` 为分片键：
 
 ```sql
-SELECT * FROM (SELECT * FROM t_order) o;
-SELECT * FROM (SELECT * FROM t_order) o WHERE o.order_id = 1;
-SELECT * FROM (SELECT * FROM t_order WHERE order_id = 1) o;
-SELECT * FROM (SELECT * FROM t_order WHERE product_id = 1) o;
-SELECT * FROM (SELECT * FROM t_order WHERE order_id = 1) o WHERE o.order_id = 2;
+SELECT * FROM t_order WHERE to_date(create_time, 'yyyy-mm-dd') = '2019-01-01';
 ```
 
-简单来说，通过子查询进行非功能需求，在大部分情况下是可以由内核支持的，比如分页、统计总数等。而通过子查询实现复杂的业务查询，需要由 Federation 执行引擎（开发中）支持。
+### 实验性支持
 
-不支持包含真实 schema 的 SQL，但支持包含逻辑 schema 的 SQL。因为 ShardingSphere 的理念是像使用一个数据源一样使用多数据源，因此对 SQL 的访问都是在同一个逻辑 schema 之上。
+实验性支持特指使用 Federation 执行引擎提供支持。
+该引擎处于快速开发中，用户虽基本可用，但仍需大量优化，是实验性产品。
 
-#### 对分片键进行操作
+#### 子查询
 
-运算表达式和函数中的分片键会导致全路由。
+子查询和外层查询未同时指定分片键，或分片键的值不一致时，由 Federation 执行引擎提供支持。
 
-假设`create_time`为分片键，则无法精确路由形如SQL：
+例如：
 
 ```sql
-SELECT * FROM t_order WHERE to_date(create_time, 'yyyy-mm-dd') = '2019-01-01';
+SELECT * FROM (SELECT * FROM t_order) o;
+
+SELECT * FROM (SELECT * FROM t_order) o WHERE o.order_id = 1;
+
+SELECT * FROM (SELECT * FROM t_order WHERE order_id = 1) o;
+
+SELECT * FROM (SELECT * FROM t_order WHERE order_id = 1) o WHERE o.order_id = 2;
 ```
 
-由于ShardingSphere只能通过SQL`字面`提取用于分片的值，因此当分片键处于运算表达式或函数中时，ShardingSphere无法提前获取分片键位于数据库中的值，从而无法计算出真正的分片值。
-
-当出现此类分片键处于运算表达式或函数中的SQL时，ShardingSphere将采用全路由的形式获取结果。
-
-### 示例
-
-#### 支持的SQL
-
-| SQL                                                                                         | 必要条件                  |
-| ------------------------------------------------------------------------------------------- | -------------------------|
-| SELECT * FROM tbl_name                                                                      |                          |
-| SELECT * FROM tbl_name WHERE (col1 = ? or col2 = ?) and col3 = ?                            |                          |
-| SELECT * FROM tbl_name WHERE col1 = ? ORDER BY col2 DESC LIMIT ?                            |                          |
-| SELECT COUNT(*), SUM(col1), MIN(col1), MAX(col1), AVG(col1) FROM tbl_name WHERE col1 = ?    |                          |
-| SELECT COUNT(col1) FROM tbl_name WHERE col2 = ? GROUP BY col1 ORDER BY col3 DESC LIMIT ?, ? |                          |
-| SELECT col1, SUM(col2) FROM tbl_name GROUP BY col1 HAVING SUM(col2) > 10                    |                          |    
-| SELECT DISTINCT * FROM tbl_name WHERE col1 = ?                                              |                          |
-| SELECT COUNT(DISTINCT col1) FROM tbl_name                                                   |                          |
-| SELECT subquery_alias.col1 FROM (select tbl_name.col1 from tbl_name where tbl_name.col2=?) subquery_alias                                                   |                                         |
-| SELECT (SELECT MAX(col1) FROM tbl_name) a, col2 from tbl_name                               |                          |
-| (SELECT * FROM tbl_name)                                                                    |                          |
-| INSERT INTO tbl_name (col1, col2,...) VALUES (?, ?, ....)                                   |                          |
-| INSERT INTO tbl_name VALUES (?, ?,....)                                                     |                          |
-| INSERT INTO tbl_name (col1, col2, ...) VALUES(1 + 2, ?, ...)                                |                          |
-| INSERT INTO tbl_name (col1, col2, ...) VALUES (?, ?, ....), (?, ?, ....)                    |                          |
-| INSERT INTO tbl_name (col1, col2, ...) SELECT col1, col2, ... FROM tbl_name WHERE col3 = ?  | INSERT表和SELECT表必须为相同表或绑定表 |
-| REPLACE INTO tbl_name (col1, col2, ...) SELECT col1, col2, ... FROM tbl_name WHERE col3 = ? | REPLACE表和SELECT表必须为相同表或绑定表 |
-| UPDATE tbl_name SET col1 = ? WHERE col2 = ?                                                 |                          |
-| DELETE FROM tbl_name WHERE col1 = ?                                                         |                          |
-| CREATE TABLE tbl_name (col1 int, ...)                                                       |                          |
-| ALTER TABLE tbl_name ADD col1 varchar(10)                                                   |                          |
-| DROP TABLE tbl_name                                                                         |                          |
-| TRUNCATE TABLE tbl_name                                                                     |                          |
-| CREATE INDEX idx_name ON tbl_name                                                           |                          |
-| DROP INDEX idx_name ON tbl_name                                                             |                          |
-| DROP INDEX idx_name                                                                         |                          |
-
-#### 不支持的SQL
-
-| SQL                                                                                        | 不支持原因                  |
-| ------------------------------------------------------------------------------------------ | -------------------------- |
-| INSERT INTO tbl_name (col1, col2, ...) SELECT * FROM tbl_name WHERE col3 = ?               | SELECT子句暂不支持使用*号简写及内置的分布式主键生成器 |
-| REPLACE INTO tbl_name (col1, col2, ...) SELECT * FROM tbl_name WHERE col3 = ?              | SELECT子句暂不支持使用*号简写及内置的分布式主键生成器 |
-| SELECT * FROM tbl_name WHERE to_date(create_time, 'yyyy-mm-dd') = ?                        | 会导致全路由                |
-| SELECT MAX(tbl_name.col1) FROM tbl_name                                                    | 查询列是函数表达式时,查询列前不能使用表名;若查询表存在别名,则可使用表的别名|
-
-### DISTINCT支持情况详细说明
-
-#### 支持的SQL
-
-| SQL                                                           |
-| ------------------------------------------------------------- |
-| SELECT DISTINCT * FROM tbl_name WHERE col1 = ?                |
-| SELECT DISTINCT col1 FROM tbl_name                            |
-| SELECT DISTINCT col1, col2, col3 FROM tbl_name                |
-| SELECT DISTINCT col1 FROM tbl_name ORDER BY col1              |
-| SELECT DISTINCT col1 FROM tbl_name ORDER BY col2              |
-| SELECT DISTINCT(col1) FROM tbl_name                           |
-| SELECT AVG(DISTINCT col1) FROM tbl_name                       |
-| SELECT SUM(DISTINCT col1) FROM tbl_name                       |
-| SELECT SUM(DISTINCT col1), SUM(col1) FROM tbl_name            |
-| SELECT COUNT(DISTINCT col1) FROM tbl_name                     |
-| SELECT COUNT(DISTINCT col1) FROM tbl_name GROUP BY col1       |
-| SELECT COUNT(DISTINCT col1 + col2) FROM tbl_name              |
-| SELECT COUNT(DISTINCT col1), SUM(DISTINCT col1) FROM tbl_name |
-| SELECT COUNT(DISTINCT col1), col1 FROM tbl_name GROUP BY col1 |
-| SELECT col1, COUNT(DISTINCT col1) FROM tbl_name GROUP BY col1 |
-
-#### 不支持的SQL
-
-| SQL                                                                                         | 不支持原因                          |
-| ------------------------------------------------------------------------------------------- |----------------------------------- |
-| SELECT SUM(DISTINCT tbl_name.col1), tbl_name.col2 FROM tbl_name                             | 查询列是函数表达式时,查询列前不能使用表名;若查询表存在别名,则可使用表的别名 |
+#### 跨库关联查询
+
+TODO
+
+### 不支持
+
+以下 CASE WHEN 语句不支持：
+
+* `CASE WHEN` 中包含子查询
+* `CASE WHEN` 中使用逻辑表名（请使用表别名）
+
+以下 UNION 和 UNION ALL 语句不支持：
+
+* 包含分片表和广播表
+
+## SQL 示例
+
+| 稳定支持的 SQL                                                                                | 必要条件                          |
+| ------------------------------------------------------------------------------------------- | -------------------------------- |
+| SELECT * FROM tbl_name                                                                      |                                  |
+| SELECT * FROM tbl_name WHERE (col1 = ? or col2 = ?) and col3 = ?                            |                                  |
+| SELECT * FROM tbl_name WHERE col1 = ? ORDER BY col2 DESC LIMIT ?                            |                                  |
+| SELECT COUNT(*), SUM(col1), MIN(col1), MAX(col1), AVG(col1) FROM tbl_name WHERE col1 = ?    |                                  |
+| SELECT COUNT(col1) FROM tbl_name WHERE col2 = ? GROUP BY col1 ORDER BY col3 DESC LIMIT ?, ? |                                  |
+| SELECT DISTINCT * FROM tbl_name WHERE col1 = ?                                              |                                  |
+| SELECT COUNT(DISTINCT col1), SUM(DISTINCT col1) FROM tbl_name                               |                                  |
+| (SELECT * FROM tbl_name)                                                                    |                                  |
+| SELECT * FROM (SELECT * FROM tbl_name WHERE col1 = ?) o WHERE o.col1 = ?                    | 子查询和外层查询在同一分片后的数据节点  |
+| INSERT INTO tbl_name (col1, col2,...) VALUES (?, ?, ....)                                   |                                  |
+| INSERT INTO tbl_name VALUES (?, ?,....)                                                     |                                  |
+| INSERT INTO tbl_name (col1, col2, ...) VALUES(1 + 2, ?, ...)                                |                                  |
+| INSERT INTO tbl_name (col1, col2, ...) VALUES (?, ?, ....), (?, ?, ....)                    |                                  |
+| INSERT INTO tbl_name (col1, col2, ...) SELECT col1, col2, ... FROM tbl_name WHERE col3 = ?  | INSERT 表和 SELECT 表相同表或绑定表  |
+| REPLACE INTO tbl_name (col1, col2, ...) SELECT col1, col2, ... FROM tbl_name WHERE col3 = ? | REPLACE 表和 SELECT 表相同表或绑定表 |
+| UPDATE tbl_name SET col1 = ? WHERE col2 = ?                                                 |                                  |
+| DELETE FROM tbl_name WHERE col1 = ?                                                         |                                  |
+| CREATE TABLE tbl_name (col1 int, ...)                                                       |                                  |
+| ALTER TABLE tbl_name ADD col1 varchar(10)                                                   |                                  |
+| DROP TABLE tbl_name                                                                         |                                  |
+| TRUNCATE TABLE tbl_name                                                                     |                                  |
+| CREATE INDEX idx_name ON tbl_name                                                           |                                  |
+| DROP INDEX idx_name ON tbl_name                                                             |                                  |
+| DROP INDEX idx_name                                                                         |                                  |
+
+***
+
+| 实验性支持的 SQL                                                           | 必要条件                          |
+| ------------------------------------------------------------------------ | -------------------------------- |
+| SELECT * FROM (SELECT * FROM tbl_name) o                                 |                                  |
+| SELECT * FROM (SELECT * FROM tbl_name) o WHERE o.col1 = ?                |                                  |
+| SELECT * FROM (SELECT * FROM tbl_name WHERE col1 = ?) o                  |                                  |
+| SELECT * FROM (SELECT * FROM tbl_name WHERE col1 = ?) o WHERE o.col1 = ? | 子查询和外层查询不在同一分片后的数据节点 |
+| SELECT (SELECT MAX(col1) FROM tbl_name) a, col2 from tbl_name            |                                  |
+| SELECT SUM(DISTINCT col1), SUM(col1) FROM tbl_name                       |                                  |
+| SELECT col1, SUM(col2) FROM tbl_name GROUP BY col1 HAVING SUM(col2) > ?  |                                  |
+
+***
+
+| 慢 SQL                                                              | 原因                        |
+| ------------------------------------------------------------------- | -------------------------- |
+| SELECT * FROM tbl_name WHERE to_date(create_time, 'yyyy-mm-dd') = ? | 分片键在运算表达式中，导致全路由 |
+
+***
+
+| 不支持的 SQL                                                                    | 原因                                 | 解决方案   |
+| ----------------------------------------------------------------------------- | ------------------------------------ | --------- |
+| INSERT INTO tbl_name (col1, col2, ...) SELECT * FROM tbl_name WHERE col3 = ?  | SELECT 子句不支持 * 和内置分布式主键生成器 |   无      |
+| REPLACE INTO tbl_name (col1, col2, ...) SELECT * FROM tbl_name WHERE col3 = ? | SELECT 子句不支持 * 和内置分布式主键生成器 |   无      |
+| SELECT MAX(tbl_name.col1) FROM tbl_name                                       | 查询列是函数表达式时，查询列前不能使用表名   | 使用表别名 |
diff --git a/docs/document/content/features/sharding/use-norms/sql.en.md b/docs/document/content/features/sharding/use-norms/sql.en.md
index 477b5afb99..14fa8040e5 100644
--- a/docs/document/content/features/sharding/use-norms/sql.en.md
+++ b/docs/document/content/features/sharding/use-norms/sql.en.md
@@ -7,44 +7,46 @@ Since the SQL syntax is flexible and complex and distributed databases and stand
 
 This document has listed identified supported SQL types and unsupported SQL types, trying to avoid traps for users.
 
-It is inevitably to have some unlisted SQLs, welcome to supplement for that. We will also try to support those unavailable SQLs in future versions.
+It is inevitably to have some unlisted SQLs, welcome to supplement for that. 
+We will also try to support those unavailable SQLs in future versions.
 
 ## Parse Engine
 
-Parse engine consists of `SQLParser` and `SQLVisitor`. `SQLParser` parses SQL into a syntax tree. `SQLVisitor` converts the syntax tree into `SQLStatement`. Parse engine supports MySQL, PostgreSQL, SQLServer, Oracle, openGauss and SQL that conform to the SQL92 specification. However, due to the complexity of SQL syntax, there are still a little of SQL that the parse engine does not support. The list is as follows:
-
-### Unsupported SQL
-#### MySQL
-
-| SQL                                                                                        | 
-| ------------------------------------------------------------------------------------------ |
-| FLUSH PRIVILEGES                                                                           | 
-| CLONE LOCAL DATA DIRECTORY = 'clone_dir'                                                   | 
-| INSTALL COMPONENT 'file://component1', 'file://component2'                                 | 
-| UNINSTALL COMPONENT 'file://component1', 'file://component2'                               | 
-| SHOW CREATE USER user                                                                      | 
-| REPAIR TABLE t_order                                                                       | 
-| OPTIMIZE TABLE t_order                                                                     | 
-| CHECKSUM TABLE t_order                                                                     | 
-| CHECK TABLE t_order                                                                        | 
-| SET RESOURCE GROUP group_name                                                              | 
-| DROP RESOURCE GROUP group_name                                                             | 
-| CREATE RESOURCE GROUP group_name TYPE = SYSTEM                                             | 
-| ALTER RESOURCE GROUP rg1 VCPU = 0-63                                                       | 
+Parse engine used to parse SQL into an abstract syntax tree.
+It supports MySQL, PostgreSQL, SQLServer, Oracle, openGauss and SQL that conform to the SQL92 specification. 
+However, due to the complexity of SQL syntax, there are still a little of SQL that the parse engine does not support.
+
+The list is as follows:
+
+| MySQL                                                        |
+| ------------------------------------------------------------ |
+| FLUSH PRIVILEGES                                             |
+| CLONE LOCAL DATA DIRECTORY = 'clone_dir'                     |
+| INSTALL COMPONENT 'file://component1', 'file://component2'   |
+| UNINSTALL COMPONENT 'file://component1', 'file://component2' |
+| SHOW CREATE USER user                                        |
+| REPAIR TABLE t_order                                         |
+| OPTIMIZE TABLE t_order                                       |
+| CHECKSUM TABLE t_order                                       |
+| CHECK TABLE t_order                                          |
+| SET RESOURCE GROUP group_name                                |
+| DROP RESOURCE GROUP group_name                               |
+| CREATE RESOURCE GROUP group_name TYPE = SYSTEM               |
+| ALTER RESOURCE GROUP rg1 VCPU = 0-63                         |
 
 ## Data Sharding
 
-### Supported SQL
+Compatible with all regular SQL when **routing to single data node**;
+**The SQL routing to multiple data nodes** is pretty complex, it divides the scenarios as totally supported, experimental supported and unsupported.
 
-#### Route to single data node
+### Totally Supported
 
-- 100% compatible（MySQL only, we are completing other databases).
+Fully support DML, DDL, DCL, TCL and most regular DAL.
+Support complex query with pagination, DISTINCT, ORDER BY, GROUP BY, aggregation and table JOIN.
 
-#### Route to multiple data nodes
+#### Regular Query
 
-Fully support DML, DDL, DCL, TCL and some DAL. Support pagination, DISTINCT, ORDER BY, GROUP BY, aggregation and JOIN. Here is an example of a most complex kind of DML:
-
-- Main SELECT
+- SELECT Clause
 
 ```sql
 SELECT select_expr [, select_expr ...] FROM table_reference [, table_reference ...]
@@ -70,124 +72,122 @@ tbl_name [AS] alias] [index_hint_list]
 | table_reference ([INNER] | {LEFT|RIGHT} [OUTER]) JOIN table_factor [JOIN ON conditional_expr | USING (column_list)]
 ```
 
-### Unsupported SQL
-
-#### Route to multiple data nodes
+#### Subquery
 
-Partially support CASE WHEN
-* `CASE WHEN` containing sub-query is not supported
-* `CASE WHEN` containing logical-table is not supported(please use alias of table)
+Stable supported when sharding keys are using in both subquery and outer query, and values of sharding keys are the same.
 
-Partly available UNION (ALL)
-* `Union (ALL)` containing sharding or broadcast table is not supported
+For example:
 
-Partly available sub-query
-* Subquery is supported by kernel when sharding keys are specified in both subquery and outer query, and values of sharding keys are the same.
-* Subquery is supported by federation executor engine (under development) when sharding keys are not specified for both subquery and outer query, or values of sharding keys are not the same.
+```sql
+SELECT * FROM (SELECT * FROM t_order WHERE order_id = 1) o WHERE o.order_id = 1;
+```
 
-Support not only pagination sub-query (see [pagination](https://shardingsphere.apache.org/document/current/cn/features/sharding/usage-standard/pagination) for more details), but also sub-query with the same mode.
+Stable supported for subquery with [pagination](https://shardingsphere.apache.org/document/current/cn/features/sharding/usage-standard/pagination).
 
-For example, the following subquery is supported by kernel:
+For example:
 
 ```sql
-SELECT * FROM (SELECT * FROM t_order WHERE order_id = 1) o WHERE o.order_id = 1;
 SELECT * FROM (SELECT row_.*, rownum rownum_ FROM (SELECT * FROM t_order) row_ WHERE rownum <= ?) WHERE rownum > ?;
 ```
 
-The following subquery is supported by federation executor engine (under development):
+#### Sharding value in expression
+
+Sharding value in calculated expressions will lead to full routing.
+
+For example, if `create_time` is sharding value:
 
 ```sql
-SELECT * FROM (SELECT * FROM t_order) o;
-SELECT * FROM (SELECT * FROM t_order) o WHERE o.order_id = 1;
-SELECT * FROM (SELECT * FROM t_order WHERE order_id = 1) o;
-SELECT * FROM (SELECT * FROM t_order WHERE product_id = 1) o;
-SELECT * FROM (SELECT * FROM t_order WHERE order_id = 1) o WHERE o.order_id = 2;
+SELECT * FROM t_order WHERE to_date(create_time, 'yyyy-mm-dd') = '2019-01-01';
 ```
 
-To be simple, through subquery, non-functional requirements are supported by kernel in most cases, such as pagination, sum count and so on. Functional requirements are supported by federation executor engine (under development).
+### Experimental Supported
 
-Do not support SQL that contains actual schema, but support SQL that contains logic schema. For the concept of ShardingSphere is to use multiple data source as one data source, so all the SQL visits are based on one logic schema.
+Experimental support specifically refers to use of `Federation execution engine`.
+The engine still in rapid development, basically available to users, but it still needs lots of optimization. 
+It is an experimental product.
 
-#### Operation for shardingColumn
+#### Subquery
 
-ShardingColumn in expressions and functions will lead to full routing.
+Experimental supported when sharding keys are not using for both subquery and outer query, or values of sharding keys are not the same.
 
-The following SQL is unavailable to single sharding, if `create_time` is shardingColumn:
+For example:
 
 ```sql
-SELECT * FROM t_order WHERE to_date(create_time, 'yyyy-mm-dd') = '2019-01-01';
+SELECT * FROM (SELECT * FROM t_order) o;
+
+SELECT * FROM (SELECT * FROM t_order) o WHERE o.order_id = 1;
+
+SELECT * FROM (SELECT * FROM t_order WHERE order_id = 1) o;
+
+SELECT * FROM (SELECT * FROM t_order WHERE order_id = 1) o WHERE o.order_id = 2;
 ```
 
-ShardingSphere extract the value of ShardingColumn through `literal` of SQL, so ShardingSphere can not calculate the sharding value from the SQL because the data inside the expression is in database.
-
-When shardingColumn in expressions and functions, ShardingSphere will use full routing to get results.
-
-### Example
-
-#### Supported SQL
-
-| SQL                                                                                         | Necessary conditions                    |
-| ------------------------------------------------------------------------------------------- | --------------------------------------- |
-| SELECT * FROM tbl_name                                                                      |                                         |
-| SELECT * FROM tbl_name WHERE (col1 = ? or col2 = ?) and col3 = ?                            |                                         |
-| SELECT * FROM tbl_name WHERE col1 = ? ORDER BY col2 DESC LIMIT ?                            |                                         |
-| SELECT COUNT(*), SUM(col1), MIN(col1), MAX(col1), AVG(col1) FROM tbl_name WHERE col1 = ?    |                                         |
-| SELECT COUNT(col1) FROM tbl_name WHERE col2 = ? GROUP BY col1 ORDER BY col3 DESC LIMIT ?, ? |                                         |
-| SELECT col1, SUM(col2) FROM tbl_name GROUP BY col1 HAVING SUM(col2) > 10                    |                                         |
-| SELECT DISTINCT * FROM tbl_name WHERE col1 = ?                                              |                                         |
-| SELECT COUNT(DISTINCT col1) FROM tbl_name                                                   |                                         |
-| SELECT subquery_alias.col1 FROM (select tbl_name.col1 from tbl_name where tbl_name.col2=?) subquery_alias                                                   |                                         |
-| SELECT (SELECT MAX(col1) FROM tbl_name) a, col2 from tbl_name                               |                                         |
-| (SELECT * FROM tbl_name)                                                                    |                                         |
-| INSERT INTO tbl_name (col1, col2,...) VALUES (?, ?, ....)                                   |                                         |
-| INSERT INTO tbl_name VALUES (?, ?,....)                                                     |                                         |
-| INSERT INTO tbl_name (col1, col2, ...) VALUES(1 + 2, ?, ...)                                |                                         |
-| INSERT INTO tbl_name (col1, col2, ...) VALUES (?, ?, ....), (?, ?, ....)                    |                                         |
-| INSERT INTO tbl_name (col1, col2, ...) SELECT col1, col2, ... FROM tbl_name WHERE col3 = ?  | The table inserted and the table selected must be the same or bind tables |
-| REPLACE INTO tbl_name (col1, col2, ...) SELECT col1, col2, ... FROM tbl_name WHERE col3 = ? | The table replaced and the table selected must be the same or bind tables |
-| UPDATE tbl_name SET col1 = ? WHERE col2 = ?                                                 |                                         |
-| DELETE FROM tbl_name WHERE col1 = ?                                                         |                                         |
-| CREATE TABLE tbl_name (col1 int, ...)                                                       |                                         |
-| ALTER TABLE tbl_name ADD col1 varchar(10)                                                   |                                         |
-| DROP TABLE tbl_name                                                                         |                                         |
-| TRUNCATE TABLE tbl_name                                                                     |                                         |
-| CREATE INDEX idx_name ON tbl_name                                                           |                                         |
-| DROP INDEX idx_name ON tbl_name                                                             |                                         |
-| DROP INDEX idx_name                                                                         |                                         |
-
-#### Unsupported SQL
-
-| SQL                                                                                        | Reason                                              |
-| ------------------------------------------------------------------------------------------ | --------------------------------------------------- |
-| INSERT INTO tbl_name (col1, col2, ...) SELECT * FROM tbl_name WHERE col3 = ?               | SELECT clause does not support *-shorthand and built-in key generators |
-| REPLACE INTO tbl_name (col1, col2, ...) SELECT * FROM tbl_name WHERE col3 = ?              | SELECT clause does not support *-shorthand and built-in key generators |
-| SELECT * FROM tbl_name WHERE to_date(create_time, 'yyyy-mm-dd') = ?                        | Lead to full routing                                |
-| SELECT MAX(tbl_name.col1) FROM tbl_name                                                    | The select function item contains TableName. Otherwise, If this query table had an alias, then TableAlias could work well in select function items. |
-
-### DISTINCT Availability Explanation
-
-#### Supported SQL
-
-| SQL                                                           |
-| ------------------------------------------------------------- |
-| SELECT DISTINCT * FROM tbl_name WHERE col1 = ?                |
-| SELECT DISTINCT col1 FROM tbl_name                            |
-| SELECT DISTINCT col1, col2, col3 FROM tbl_name                |
-| SELECT DISTINCT col1 FROM tbl_name ORDER BY col1              |
-| SELECT DISTINCT col1 FROM tbl_name ORDER BY col2              |
-| SELECT DISTINCT(col1) FROM tbl_name                           |
-| SELECT AVG(DISTINCT col1) FROM tbl_name                       |
-| SELECT SUM(DISTINCT col1) FROM tbl_name                       |
-| SELECT SUM(DISTINCT col1), SUM(col1) FROM tbl_name            |
-| SELECT COUNT(DISTINCT col1) FROM tbl_name                     |
-| SELECT COUNT(DISTINCT col1) FROM tbl_name GROUP BY col1       |
-| SELECT COUNT(DISTINCT col1 + col2) FROM tbl_name              |
-| SELECT COUNT(DISTINCT col1), SUM(DISTINCT col1) FROM tbl_name |
-| SELECT COUNT(DISTINCT col1), col1 FROM tbl_name GROUP BY col1 |
-| SELECT col1, COUNT(DISTINCT col1) FROM tbl_name GROUP BY col1 |
-
-#### Unsupported SQL
-
-| SQL                                                | Reason                                                                             |
-| -------------------------------------------------- | ---------------------------------------------------------------------------------- |
-| SELECT SUM(DISTINCT tbl_name.col1), tbl_name.col2 FROM tbl_name | The select function item contains TableName. Otherwise, If this query table had an alias, then TableAlias could work well in select function items. |
\ No newline at end of file
+#### Join with cross databases
+
+TODO
+
+### Unsupported
+
+CASE WHEN can not support as following:
+
+* `CASE WHEN` containing sub-query
+* `CASE WHEN` containing logical-table (instead of table alias)
+
+UNION and UNION ALL can not support as following:
+
+* containing sharding or broadcast table
+
+### SQL Example
+
+| Stable supported SQL                                                                        | Necessary conditions                                           |
+| ------------------------------------------------------------------------------------------- | -------------------------------------------------------------- |
+| SELECT * FROM tbl_name                                                                      |                                                                |
+| SELECT * FROM tbl_name WHERE (col1 = ? or col2 = ?) and col3 = ?                            |                                                                |
+| SELECT * FROM tbl_name WHERE col1 = ? ORDER BY col2 DESC LIMIT ?                            |                                                                |
+| SELECT COUNT(*), SUM(col1), MIN(col1), MAX(col1), AVG(col1) FROM tbl_name WHERE col1 = ?    |                                                                |
+| SELECT COUNT(col1) FROM tbl_name WHERE col2 = ? GROUP BY col1 ORDER BY col3 DESC LIMIT ?, ? |                                                                |
+| SELECT DISTINCT * FROM tbl_name WHERE col1 = ?                                              |                                                                |
+| SELECT COUNT(DISTINCT col1), SUM(DISTINCT col1) FROM tbl_name                               |                                                                |
+| (SELECT * FROM tbl_name)                                                                    |                                                                |
+| SELECT * FROM (SELECT * FROM tbl_name WHERE col1 = ?) o WHERE o.col1 = ?                    | Subquery and outer query in same sharded data node after route |
+| INSERT INTO tbl_name (col1, col2,...) VALUES (?, ?, ....)                                   |                                                                |
+| INSERT INTO tbl_name VALUES (?, ?,....)                                                     |                                                                |
+| INSERT INTO tbl_name (col1, col2, ...) VALUES(1 + 2, ?, ...)                                |                                                                |
+| INSERT INTO tbl_name (col1, col2, ...) VALUES (?, ?, ....), (?, ?, ....)                    |                                                                |
+| INSERT INTO tbl_name (col1, col2, ...) SELECT col1, col2, ... FROM tbl_name WHERE col3 = ?  | Inserted and selected table must be the same or binding tables |
+| REPLACE INTO tbl_name (col1, col2, ...) SELECT col1, col2, ... FROM tbl_name WHERE col3 = ? | Replaced and selected table must be the same or binding tables |
+| UPDATE tbl_name SET col1 = ? WHERE col2 = ?                                                 |                                                                |
+| DELETE FROM tbl_name WHERE col1 = ?                                                         |                                                                |
+| CREATE TABLE tbl_name (col1 int, ...)                                                       |                                                                |
+| ALTER TABLE tbl_name ADD col1 varchar(10)                                                   |                                                                |
+| DROP TABLE tbl_name                                                                         |                                                                |
+| TRUNCATE TABLE tbl_name                                                                     |                                                                |
+| CREATE INDEX idx_name ON tbl_name                                                           |                                                                |
+| DROP INDEX idx_name ON tbl_name                                                             |                                                                |
+| DROP INDEX idx_name                                                                         |                                                                |
+
+***
+
+| Experimental supported SQL                                               | Necessary conditions                                                |
+| ------------------------------------------------------------------------ | ------------------------------------------------------------------- |
+| SELECT * FROM (SELECT * FROM tbl_name) o                                 |                                                                     |
+| SELECT * FROM (SELECT * FROM tbl_name) o WHERE o.col1 = ?                |                                                                     |
+| SELECT * FROM (SELECT * FROM tbl_name WHERE col1 = ?) o                  |                                                                     |
+| SELECT * FROM (SELECT * FROM tbl_name WHERE col1 = ?) o WHERE o.col1 = ? | Subquery and outer query in different sharded data node after route |
+| SELECT (SELECT MAX(col1) FROM tbl_name) a, col2 from tbl_name            |                                                                     |
+| SELECT SUM(DISTINCT col1), SUM(col1) FROM tbl_name                       |                                                                     |
+| SELECT col1, SUM(col2) FROM tbl_name GROUP BY col1 HAVING SUM(col2) > ?  |                                                                     |
+
+***
+
+| Slow SQL                                                            | Reason                                                       |
+| ------------------------------------------------------------------- | ------------------------------------------------------------ |
+| SELECT * FROM tbl_name WHERE to_date(create_time, 'yyyy-mm-dd') = ? | Full route because of sharding value in calculate expression |
+
+***
+
+| Unsupported SQL                                                               | Reason                                                                | Solution               |
+| ----------------------------------------------------------------------------- | --------------------------------------------------------------------- | ---------------------- |
+| INSERT INTO tbl_name (col1, col2, ...) SELECT * FROM tbl_name WHERE col3 = ?  | SELECT clause does not support *-shorthand and built-in key generator | -                      |
+| REPLACE INTO tbl_name (col1, col2, ...) SELECT * FROM tbl_name WHERE col3 = ? | SELECT clause does not support *-shorthand and built-in key generator | -                      |
+| SELECT MAX(tbl_name.col1) FROM tbl_name                                       | Use table name as column owner in function                            | Instead of table alias |
