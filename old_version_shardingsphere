commit 8da8977abf494aa7cfb1a42b9063e79550fd5983
Author: Mike0601 <40025573+Mike0601@users.noreply.github.com>
Date:   Thu Jul 28 11:31:46 2022 +0800

    update (#19622)

diff --git a/docs/document/content/test-manual/integration-test/_index.en.md b/docs/document/content/test-manual/integration-test/_index.en.md
index 9496f6a5448..c8775b37fec 100644
--- a/docs/document/content/test-manual/integration-test/_index.en.md
+++ b/docs/document/content/test-manual/integration-test/_index.en.md
@@ -4,163 +4,168 @@ title = "Integration Test"
 weight = 1
 +++
 
-The SQL parsing unit test covers both SQL placeholder and literal dimension. 
-Integration test can be further divided into two dimensions of strategy and JDBC; the former one includes strategies as Sharding, table Sharding, database Sharding, and readwrite-splitting while the latter one includes `Statement` and `PreparedStatement`.
+## Design
 
-Therefore, one SQL can drive 5 kinds of database parsing * 2 kinds of parameter transmission modes + 5 kinds of databases * 5 kinds of Sharding strategies * 2 kinds of JDBC operation modes = 60 test cases, to enable ShardingSphere to achieve the pursuit of high quality.
+The integration testing consists of three modules: test case, test environment and test engine.
 
-## Process
+### Test case
 
-The `Parameterized` in JUnit will collect all test data, and pass to test method to assert one by one. The process of handling test data is just like a leaking hourglass:
+It is used to define the SQL to be tested and the assertion data of the test results.
 
-### Configuration
- 
-  - environment type
-    - /shardingsphere-integration-test-suite/src/test/resources/env-native.properties
-    - /shardingsphere-integration-test-suite/src/test/resources/env/`SQL-TYPE`/dataset.xml
-    - /shardingsphere-integration-test-suite/src/test/resources/env/`SQL-TYPE`/schema.xml
-  - test case type
-    - /shardingsphere-integration-test-suite/src/test/resources/cases/`SQL-TYPE`/`SQL-TYPE`-integration-test-cases.xml
-    - /shardingsphere-integration-test-suite/src/test/resources/cases/`SQL-TYPE`/dataset/`FEATURE-TYPE`/*.xml
-  - sql-case 
-    - /sharding-sql-test/src/main/resources/sql/sharding/`SQL-TYPE`/*.xml
+Each case defines one SQL, which can define multiple database execution types.
 
-### Environment Configuration
+### Test environment
 
-Integration test depends on existed database environment, developer need to setup the configuration file for corresponding database to test: 
+It is used to set up the database and ShardingSphere-Proxy environment for running test cases.
+The environment is classified into environment preparation mode, database type, and scenario.
 
-Firstly, setup configuration file `/shardingsphere-integration-test-suite/src/test/resources/env-native.properties`, for example: 
+Environment preparation mode is divided into Native and Docker, and Embed type will be supported in the future.
+  - Native environment is used for test cases to run directly in the test environment provided by the developer, suitable for debugging scenarios;
+  - Docker environment is directly built when Maven runs the Docker-Compose plug-in. It is suitable for cloud compilation environment and testing ShardingSphere-Proxy, such as GitHub Action;
+  - Embed environment is built when the test framework automatically builds embedded MySQL. It is suitable for the local environment test of ShardingSphere-JDBC.
 
-```properties
-# running mode，could define multiple mode(Standalone,Cluster)
-it.run.modes=Cluster
+Currently, the Native environment is adopted by default, and ShardingSphere-JDBC + H2 database is used to run test cases.
+Maven's `-pit. Env.docker` parameter specifies how the Docker environment is run.
+In the future, ShardingSphere-JDBC + MySQL of the Embed environment will be adopted to replace the default environment type used when Native executes test cases.
 
-# the switch for PK, concurrent, column index testing and so on
-it.run.additional.cases=false
+Database types currently support MySQL, PostgreSQL, SQLServer, and Oracle, and test cases can be executed using ShardingSphere-JDBC or ShardingSphere-Proxy.
 
-# test scenarios, could define multiple rules
-it.scenarios=db,tbl,dbtbl_with_replica_query,replica_query
+Scenarios are used to test the supporting rules of ShardingSphere. Currently, data sharding and read/write splitting and other related scenarios are supported, and the combination of scenarios will be improved continuously in the future. 
 
-# database type, could define multiple databases(H2,MySQL,Oracle,SQLServer,PostgreSQL)
-it.cluster.databases=MySQL,PostgreSQL
-
-# MySQL configuration
-it.mysql.host=127.0.0.1
-it.mysql.port=13306
-it.mysql.username=root
-it.mysql.password=root
-
-## PostgreSQL configuration
-it.postgresql.host=db.psql
-it.postgresql.port=5432
-it.postgresql.username=postgres
-it.postgresql.password=postgres
-
-## SQLServer configuration
-it.sqlserver.host=db.mssql
-it.sqlserver.port=1433
-it.sqlserver.username=sa
-it.sqlserver.password=Jdbc1234
-
-## Oracle configuration
-it.oracle.host=db.oracle
-it.oracle.port=1521
-it.oracle.username=jdbc
-it.oracle.password=jdbc
-```
+### Test engine
 
-Secondly, setup configuration file `/shardingsphere-integration-test-suite/src/test/resources/env/SQL-TYPE/dataset.xml`. 
-Developer can set up metadata and expected data to start the data initialization in `dataset.xml`. For example: 
+It is used to read test cases in batches and execute and assert test results line by line.
 
-```xml
-<dataset>
-    <metadata data-nodes="tbl.t_order_${0..9}">
-        <column name="order_id" type="numeric" />
-        <column name="user_id" type="numeric" />
-        <column name="status" type="varchar" />
-    </metadata>
-    <row data-node="tbl.t_order_0" values="1000, 10, init" />
-    <row data-node="tbl.t_order_1" values="1001, 10, init" />
-    <row data-node="tbl.t_order_2" values="1002, 10, init" />
-    <row data-node="tbl.t_order_3" values="1003, 10, init" />
-    <row data-node="tbl.t_order_4" values="1004, 10, init" />
-    <row data-node="tbl.t_order_5" values="1005, 10, init" />
-    <row data-node="tbl.t_order_6" values="1006, 10, init" />
-    <row data-node="tbl.t_order_7" values="1007, 10, init" />
-    <row data-node="tbl.t_order_8" values="1008, 10, init" />
-    <row data-node="tbl.t_order_9" values="1009, 10, init" />
-</dataset>
-```
+The test engine arranges test cases and environments to test as many scenarios as possible with the fewest test cases.
+
+Each SQL generates a test report in the combination of `database type * access port type * SQL execution mode * JDBC execution mode * Scenario`. Currently, each dimension is supported as follows:
 
-Developer can customize DDL to create databases and tables in `schema.xml`.
+  - Database types: H2, MySQL, PostgreSQL, SQLServer, and Oracle;
+  - Access port types: ShardingSphere-JDBC and ShardingSphere-Proxy;
+  - SQL execution modes: Statement and PreparedStatement;
+  - JDBC execution modes: execute and executeQuery/executeUpdate;
+  - Scenarios: database shards, table shards, read/write splitting and sharding + read/write splitting
 
-### Assertion Configuration
+Therefore, one SQL will drive `Database type (5) * Access port type (2) * SQL execution mode (2) * JDBC execution mode (2) * Scenario (4) = 160` test cases to be run to achieve the pursuit of high quality.
 
-So far have confirmed what kind of sql execute in which environment in upon configuration, here define the data for assert.
-There are two kinds of config for assert, one is at `/shardingsphere-integration-test-suite/src/test/resources/cases/SQL-TYPE/SQL-TYPE-integration-test-cases.xml`.
-This file just like an index, defined the sql, parameters and expected index position for execution. the SQL is the value for `sql-case-id`. For example: 
+## User Guide
+
+Module path：`shardingsphere-test/shardingsphere-integration-test/shardingsphere-integration-test-suite`
+
+### Test case configuration
+
+SQL test case is in `resources/cases/${SQL-TYPE}/${SQL-TYPE}-integration-test-cases.xml`.
+
+The case file format is as follows:
 
 ```xml
 <integration-test-cases>
-    <dml-test-case sql-case-id="insert_with_all_placeholders">
-       <assertion parameters="1:int, 1:int, insert:String" expected-data-file="insert_for_order_1.xml" />
-       <assertion parameters="2:int, 2:int, insert:String" expected-data-file="insert_for_order_2.xml" />
-    </dml-test-case>
+    <test-case sql="${SQL}">
+        <assertion parameters="${value_1}:${type_1}, ${value_2}:${type_2}" expected-data-file="${dataset_file_1}.xml" />
+        <!-- ... more assertions -->
+        <assertion parameters="${value_3}:${type_3}, ${value_4}:${type_4}" expected-data-file="${dataset_file_2}.xml" />
+     </test-case>
+    
+    <!-- ... more test cases -->
 </integration-test-cases>
 ```
 
-Another kind of config for assert is the data, as known as the corresponding expected-data-file in SQL-TYPE-integration-test-cases.xml, which is at `/shardingsphere-integration-test-suite/src/test/resources/cases/SQL-TYPE/dataset/FEATURE-TYPE/*.xml`.  
-This file is very like the dataset.xml mentioned before, and the difference is that expected-data-file contains some other assert data, such as the return value after a sql execution. For examples:  
+The lookup rule of `expected-data-file`is as follows: 
+  1. Find the file `dataset\${SCENARIO_NAME}\${DATABASE_TYPE}\${dataset_file}.xml` in the same level directory;
+  2. Find the file `dataset\${SCENARIO_NAME}\${dataset_file}.xml` in the same level directory;
+  3. Find the file `dataset\${dataset_file}.xml` in the same level directory;
+  4. Report an error if none of them are found.
+
+The assertion file format is as follows:
 
 ```xml
-<dataset update-count="1">
-    <metadata data-nodes="db_${0..9}.t_order">
-        <column name="order_id" type="numeric" />
-        <column name="user_id" type="numeric" />
-        <column name="status" type="varchar" />
+<dataset>
+    <metadata>
+        <column name="column_1" />
+        <!-- ... more columns -->
+        <column name="column_n" />
     </metadata>
-    <row data-node="db_0.t_order" values="1000, 10, update" />
-    <row data-node="db_0.t_order" values="1001, 10, init" />
-    <row data-node="db_0.t_order" values="2000, 20, init" />
-    <row data-node="db_0.t_order" values="2001, 20, init" />
+    <row values="value_01, value_02" />
+    <!-- ... more rows -->
+    <row values="value_n1, value_n2" />
 </dataset>
 ```
-Util now, all config files are ready, just launch the corresponding test case is fine.With no need to modify any Java code, only set up some config files.
-This will reduce the difficulty for ShardingSphere testing.
 
-### Running Integration Tests
+### Environment configuration
 
-#### Run with Docker
+`${SCENARIO-TYPE}` Refers to the scenario name used to identify a unique scenario during the test engine run.
+`${DATABASE-TYPE}` refers to the database types.
 
-```bash
-./mvnw -B clean install -f shardingsphere-test/shardingsphere-integration-test/pom.xml -Pit.env.docker -Dit.cluster.adapters=proxy,jdbc -Dit.scenarios=${scenario_name_1,scenario_name_1,scenario_name_n} -Dit.cluster.databases=MySQL
-```
+#### Native environment configuration
 
-Running the above command will build a Docker image `apache/shardingsphere-proxy-test:latest` for integration testing.
-The existing test Docker image can be reused without rebuilding if only the test code is modified.
-Use the following command to skip the image building and run the integration tests directly:
+Directory: `src/test/resources/env/${SCENARIO-TYPE}`
 
-```bash
-./mvnw -B clean install -f shardingsphere-test/shardingsphere-integration-test/shardingsphere-integration-test-suite/pom.xml -Pit.env.docker -Dit.cluster.adapters=proxy,jdbc -Dit.scenarios=${scenario_name_1,scenario_name_1,scenario_name_n} -Dit.cluster.databases=MySQL
+  - `scenario-env.properties`: data source configuration；
+  - `rules.yaml`: rule configuration；
+  - `databases.xml`: name of the real database；
+  - `dataset.xml`: initialize the data；
+  - `init-sql\${DATABASE-TYPE}\init.sql`: initialize the database and table structure；
+  - `authority.xml`: to be supplemented.
+
+#### Docker environment configuration
+
+Directory: `src/test/resources/docker/${SCENARIO-TYPE}`
+
+  - `docker-compose.yml`: Docker-Compose config files, used for Docker environment startup；
+  - `proxy/conf/config-${SCENARIO-TYPE}.yaml`: rule configuration。
+
+**The Docker environment configuration provides a remote debugging port for ShardingSphere-Proxy. You can find the second exposed port for remote debugging in `shardingsphere-proxy` of the `docker-comemage. yml` file. **
+
+### Run the test engine
+
+#### Configure the running environment of the test engine
+
+Control the test engine by configuring `src/test/resources/env/engine-env.properties`. 
+
+All attribute values can be dynamically injected via Maven command line `-D`.
+
+```properties
+
+# Scenario type. Multiple values can be separated by commas. Optional values: db, tbl, dbtbl_with_replica_query, replica_query
+it.scenarios=db,tbl,dbtbl_with_replica_query,replica_query
+
+# Whether to run additional test cases
+it.run.additional.cases=false
+
+# Configure the environment type. Only one value is supported. Optional value: docker or null. The default value: null. 
+it.cluster.env.type=${it.env}
+# Access port types to be tested. Multiple values can be separated by commas. Optional value: jdbc, proxy. The default value: jdbc
+it.cluster.adapters=jdbc
+
+# Scenario type. Multiple values can be separated by commas. Optional value: H2, MySQL, Oracle, SQLServer, PostgreSQL
+it.cluster.databases=H2,MySQL,Oracle,SQLServer,PostgreSQL
 ```
 
-#### debug the Proxy inside docker container
+#### Run debugging mode
 
-The Proxy Image for testing expose the port 3308 for remote debug the instance inside docker container.
+  - Standard test engine
+    Run `org.apache.shardingsphere.test.integration.engine.${SQL-TYPE}.General${SQL-TYPE}IT` to start the test engines of different SQL types.
 
-Use IDE like IDEA could connect and debug the Proxy in container by following steps:
+  - Batch test engine
+    Run `org.apache.shardingsphere.test.integration.engine.dml.BatchDMLIT` to start the batch test engine for the test `addBatch()` provided for DML statements.
 
-IDEA -> Run -> Edit Configurations -> Add New Configuration -> Remote JVM Debug
+  - Additional test engine
+    Run `org.apache.shardingsphere.test.integration.engine.${SQL-TYPE}.Additional${SQL-TYPE}IT` to start the test engine with more JDBC method calls.
+    Additional test engines need to be enabled by setting `it.run.additional.cases=true`.
 
-Edit the corresponding info:
-  - Name: a name for this, like docker-debug
-  - Host: the IP could access container, like 127.0.0.1
-  - Port: the debug port 3308
-  - use module classpath: project root directory shardingsphere
+#### Run Docker mode
 
-After edit and save the upon info, goto Run -> Run -> docker-debug will start the remote debug to the Proxy instance inside docker container.
+```bash
+./mvnw -B clean install -f shardingsphere-test/shardingsphere-integration-test/pom.xml -Pit.env.docker -Dit.cluster.adapters=proxy,jdbc -Dit.scenarios=${scenario_name_1,scenario_name_2,scenario_name_n} -Dit.cluster.databases=MySQL
+```
+Run the above command to build a Docker mirror `apache/shardingsphere-proxy-test:latest` used for integration testing.
+If you only modify the test code, you can reuse the existing test mirror without rebuilding it. Skip the mirror building and run the integration testing directly with the following command:
+
+```bash
+./mvnw -B clean install -f shardingsphere-test/shardingsphere-integration-test/shardingsphere-integration-test-suite/pom.xml -Pit.env.docker -Dit.cluster.adapters=proxy,jdbc -Dit.scenarios=${scenario_name_1,scenario_name_2,scenario_name_n} -Dit.cluster.databases=MySQL
+```
 
-## Notice
+#### Notice
 
-1. If Oracle needs to be tested, please add Oracle driver dependencies to the pom.xml.
-1. 10 splitting-databases and 10 splitting-tables are used in the integrated test to ensure the test data is full, so it will take a relatively long time to run the test cases.
+1. To test Oracle, add an Oracle driver dependency to pom.xml.
+1. In order to ensure the integrity and legibility of the test data, 10 database shards and 10 table shards are used in the sharding of the integration testing, which takes a long time to run the test cases completely.
\ No newline at end of file
