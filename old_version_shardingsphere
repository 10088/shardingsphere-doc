commit 50b93456e88aaab3442d263ebc914a26b3748e31
Author: Zhengqiang Duan <duanzhengqiang@apache.org>
Date:   Thu Mar 31 11:54:16 2022 +0800

    Optimize binding table doc (#16508)

diff --git a/docs/document/content/features/sharding/concept/table.cn.md b/docs/document/content/features/sharding/concept/table.cn.md
index f0c86393c0..cb4c44afca 100644
--- a/docs/document/content/features/sharding/concept/table.cn.md
+++ b/docs/document/content/features/sharding/concept/table.cn.md
@@ -18,7 +18,7 @@ Apache ShardingSphere 通过提供多样化的表类型，适配不同场景下
 
 ## 绑定表
 
-指分片规则一致的主表和子表。
+指分片规则一致的一组分片表。
 使用绑定表进行多表关联查询时，必须使用分片键进行关联，否则会出现笛卡尔积关联或跨库关联，从而影响查询效率。
 例如：`t_order` 表和 `t_order_item` 表，均按照 `order_id` 分片，并且使用 `order_id` 进行关联，则此两张表互为绑定表关系。
 绑定表之间的多表关联查询不会出现笛卡尔积关联，关联查询效率将大大提升。
@@ -48,9 +48,8 @@ SELECT i.* FROM t_order_0 o JOIN t_order_item_0 i ON o.order_id=i.order_id WHERE
 SELECT i.* FROM t_order_1 o JOIN t_order_item_1 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);
 ```
 
-其中 `t_order` 在 FROM 的最左侧，ShardingSphere 将会以它作为整个绑定表的主表。
+其中 `t_order` 表由于指定了分片条件，ShardingSphere 将会以它作为整个绑定表的主表。
 所有路由计算将会只使用主表的策略，那么 `t_order_item` 表的分片计算将会使用 `t_order` 的条件。
-因此，绑定表间的分区键需要完全相同。
 
 ## 广播表
 
diff --git a/docs/document/content/features/sharding/concept/table.en.md b/docs/document/content/features/sharding/concept/table.en.md
index 7357d703dd..dd840acae3 100644
--- a/docs/document/content/features/sharding/concept/table.en.md
+++ b/docs/document/content/features/sharding/concept/table.en.md
@@ -17,7 +17,7 @@ The physical table that really exists in the horizontal sharding database, i.e.,
 
 ## Binding Table
 
-It refers to the primary table and the joiner table with the same sharding rules.
+It refers to a group of sharding tables with the same sharding rules.
 When using binding tables in multi-table correlating query, you must use the sharding key for correlation, otherwise Cartesian product correlation or cross-database correlation will appear, which will affect query efficiency.
 For example, `t_order` and `t_order_item` are both sharded by `order_id`, and use `order_id` to correlate, so they are binding tables with each other. 
 Cartesian product correlation will not appear in the multi-tables correlating query, so the query efficiency will increase greatly.
@@ -47,10 +47,8 @@ SELECT i.* FROM t_order_0 o JOIN t_order_item_0 i ON o.order_id=i.order_id WHERE
 SELECT i.* FROM t_order_1 o JOIN t_order_item_1 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);
 ```
 
-In them, table `t_order` in the left end of FROM will be taken by ShardingSphere as the primary table of query.
-In a similar way, ShardingSphere will also take table `t_order` in the left end of FROM as the primary table of the whole binding table. 
-All the route computations will only use the sharding strategy of the primary table, so sharding computation of `t_order_item` table will use the conditions of `t_order`. 
-Due to this, sharding keys in binding tables should be totally identical.
+In them, since table `t_order` specifies sharding conditions， it will be taken by ShardingSphere as the primary table of query. 
+All the route computations will only use the sharding strategy of the primary table, so sharding computation of `t_order_item` table will use the conditions of `t_order`.
 
 ## Broadcast Table
 
