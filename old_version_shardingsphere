commit 58ca96c0d9da3b91c923e0f08714f5e0be25d91a
Author: Liang Zhang <terrymanu@163.com>
Date:   Thu Oct 28 21:34:57 2021 +0800

    Update inline-expression (#13339)

diff --git a/docs/document/content/features/sharding/concept/inline-expression.cn.md b/docs/document/content/features/sharding/concept/inline-expression.cn.md
index 8c53c1b2f9..12dd403081 100644
--- a/docs/document/content/features/sharding/concept/inline-expression.cn.md
+++ b/docs/document/content/features/sharding/concept/inline-expression.cn.md
@@ -7,14 +7,18 @@ weight = 4
 
 配置的简化与一体化是行表达式所希望解决的两个主要问题。
 
-在繁琐的数据分片规则配置中，随着数据节点的增多，大量的重复配置使得配置本身不易被维护。通过行表达式可以有效地简化数据节点配置工作量。
+在繁琐的数据分片规则配置中，随着数据节点的增多，大量的重复配置使得配置本身不易被维护。
+通过行表达式可以有效地简化数据节点配置工作量。
 
-对于常见的分片算法，使用 Java 代码实现并不有助于配置的统一管理。通过行表达式书写分片算法，可以有效地将规则配置一同存放，更加易于浏览与存储。
+对于常见的分片算法，使用 Java 代码实现并不有助于配置的统一管理。
+通过行表达式书写分片算法，可以有效地将规则配置一同存放，更加易于浏览与存储。
 
 ## 语法说明
 
 行表达式的使用非常直观，只需要在配置中使用 `${ expression }` 或 `$->{ expression }` 标识行表达式即可。
-目前支持数据节点和分片算法这两个部分的配置。行表达式的内容使用的是 Groovy 的语法，Groovy 能够支持的所有操作，行表达式均能够支持。例如：
+目前支持数据节点和分片算法这两个部分的配置。
+行表达式的内容使用的是 Groovy 的语法，Groovy 能够支持的所有操作，行表达式均能够支持。
+例如：
 
 `${begin..end}` 表示范围区间
 
@@ -34,16 +38,18 @@ ${['online', 'offline']}_table${1..3}
 online_table1, online_table2, online_table3, offline_table1, offline_table2, offline_table3
 ```
 
-## 配置数据节点
+## 配置
+
+###数据节点
 
 对于均匀分布的数据节点，如果数据结构如下：
 
 ```
 db0
-  ├── t_order0 
-  └── t_order1 
+  ├── t_order0
+  └── t_order1
 db1
-  ├── t_order0 
+  ├── t_order0
   └── t_order1
 ```
 
@@ -63,8 +69,8 @@ db$->{0..1}.t_order$->{0..1}
 
 ```
 db0
-  ├── t_order0 
-  └── t_order1 
+  ├── t_order0
+  └── t_order1
 db1
   ├── t_order2
   ├── t_order3
@@ -145,7 +151,7 @@ db${0..1}.t_order_0${0..9}, db${0..1}.t_order_${10..20}
 db$->{0..1}.t_order_0$->{0..9}, db$->{0..1}.t_order_$->{10..20}
 ```
 
-## 配置分片算法
+### 分片算法
 
 对于只有一个分片键的使用 `=` 和 `IN` 进行分片的 SQL，可以使用行表达式代替编码方式配置。
 
@@ -153,12 +159,12 @@ db$->{0..1}.t_order_0$->{0..9}, db$->{0..1}.t_order_$->{10..20}
 
 例如：分为 10 个库，尾数为 0 的路由到后缀为 0 的数据源， 尾数为 1 的路由到后缀为 1 的数据源，以此类推。用于表示分片算法的行表达式为：
 
-``` 
+```
 ds${id % 10}
 ```
 
 或者
 
-``` 
+```
 ds$->{id % 10}
 ```
diff --git a/docs/document/content/features/sharding/concept/inline-expression.en.md b/docs/document/content/features/sharding/concept/inline-expression.en.md
index 5877b6802a..8b05f14b6e 100644
--- a/docs/document/content/features/sharding/concept/inline-expression.en.md
+++ b/docs/document/content/features/sharding/concept/inline-expression.en.md
@@ -7,19 +7,26 @@ weight = 4
 
 Configuration simplicity and unity are two main problems that inline expression intends to solve.
 
-In complex sharding rules, with more data nodes, a large number of configuration repetitions make configurations difficult to maintain. Inline expressions can simplify data node configuration work.
+In complex sharding rules, with more data nodes, a large number of configuration repetitions make configurations difficult to maintain. 
+Inline expressions can simplify data node configuration work.
 
-Java codes are not helpful in the unified management of common configurations. Writing sharding algorithms with inline expressions, users can stored rules together, making them easier to be browsed and stored.
+Java codes are not helpful in the unified management of common configurations. 
+Writing sharding algorithms with inline expressions, users can store rules together, making them easier to be browsed and stored.
 
 ## Syntax Explanation
 
-The use of inline expressions is really direct. Users only need to configure `${ expression }` or `$->{ expression }` to identify them. ShardingSphere currently supports the configurations of data nodes and sharding algorithms. Inline expressions use Groovy syntax, which can support all kinds of operations, including inline expressions. For example:
+The use of inline expressions is really direct. 
+Users only need to configure `${ expression }` or `$->{ expression }` to identify them. 
+ShardingSphere currently supports the configurations of data nodes and sharding algorithms. 
+Inline expressions use Groovy syntax, which can support all kinds of operations, including inline expressions. 
+For example:
 
 `${begin..end}` means range
 
 `${[unit1, unit2, unit_x]}` means enumeration
 
-If there are many continuous `${ expression }` or `$->{ expression }` expressions, according to each sub-expression result, the ultimate result of the whole expression will be in cartesian combination.
+If there are many continuous `${ expression }` or `$->{ expression }` expressions, 
+according to each sub-expression result, the ultimate result of the whole expression will be in cartesian combination.
 
 For example, the following inline expression:
 
@@ -33,16 +40,18 @@ Will be parsed as:
 online_table1, online_table2, online_table3, offline_table1, offline_table2, offline_table3
 ```
 
-## Data Node Configuration
+## Configuration
+
+### Data Node
 
 For evenly distributed data nodes, if the data structure is as follow:
 
 ```
 db0
-  ├── t_order0 
-  └── t_order1 
+  ├── t_order0
+  └── t_order1
 db1
-  ├── t_order0 
+  ├── t_order0
   └── t_order1
 ```
 
@@ -62,8 +71,8 @@ For self-defined data nodes, if the data structure is:
 
 ```
 db0
-  ├── t_order0 
-  └── t_order1 
+  ├── t_order0
+  └── t_order1
 db1
   ├── t_order2
   ├── t_order3
@@ -144,7 +153,7 @@ Or
 db$->{0..1}.t_order_0$->{0..9}, db$->{0..1}.t_order_$->{10..20}
 ```
 
-## Sharding Algorithm Configuration
+### Sharding Algorithm
 
 For single sharding SQL that uses `=` and `IN`, inline expression can replace codes in configuration.
 
