commit 2bc51ecfc47bc9dae8aa5faced4f0b838fbc6bc7
Author: Zhengqiang Duan <duanzhengqiang@apache.org>
Date:   Mon Jul 11 16:50:51 2022 +0800

    Update encrypt document for core feature (#19022)
    
    * Update encrypt document for core feature
    
    * update document
    
    * update document

diff --git a/docs/document/content/features/db- gateway/_index.cn.md b/docs/document/content/features/db-gateway/_index.cn.md
similarity index 100%
rename from docs/document/content/features/db- gateway/_index.cn.md
rename to docs/document/content/features/db-gateway/_index.cn.md
diff --git a/docs/document/content/features/db- gateway/_index.en.md b/docs/document/content/features/db-gateway/_index.en.md
similarity index 100%
rename from docs/document/content/features/db- gateway/_index.en.md
rename to docs/document/content/features/db-gateway/_index.en.md
diff --git a/docs/document/content/features/encrypt/_index.cn.md b/docs/document/content/features/encrypt/_index.cn.md
index f62d8e0ba1e..d8b01e62614 100644
--- a/docs/document/content/features/encrypt/_index.cn.md
+++ b/docs/document/content/features/encrypt/_index.cn.md
@@ -5,31 +5,101 @@ weight = 9
 chapter = true
 +++
 
-## 背景
+## 定义
 
-安全控制一直是治理的重要环节，数据加密属于安全控制的范畴。
-无论对互联网公司还是传统行业来说，数据安全一直是极为重视和敏感的话题。
 数据加密是指对某些敏感信息通过加密规则进行数据的变形，实现敏感隐私数据的可靠保护。
 涉及客户安全数据或者一些商业性敏感数据，如身份证号、手机号、卡号、客户号等个人信息按照相关部门规定，都需要进行数据加密。
 
-对于数据加密的需求，在现实的业务场景中一般分为两种情况：
+## 相关概念
 
-1. 新业务上线，安全部门规定需将涉及用户敏感信息，例如银行、手机号码等进行加密后存储到数据库，在使用的时候再进行解密处理。因为是全新系统，因而没有存量数据清洗问题，所以实现相对简单。
+### 逻辑列
 
-2. 已上线业务，之前一直将明文存储在数据库中。相关部门突然需要对已上线业务进行加密整改。这种场景一般需要处理 3 个问题：
+用于计算加解密列的逻辑名称，是 SQL 中列的逻辑标识。
+逻辑列包含密文列（必须）、查询辅助列（可选）和明文列（可选）。
 
-* 历史数据需要如何进行加密处理，即洗数。
-* 如何能在不改动业务 SQL 和逻辑情况下，将新增数据进行加密处理，并存储到数据库；在使用时，再进行解密取出。
-* 如何较为安全、无缝、透明化地实现业务系统在明文与密文数据间的迁移。
+### 密文列
 
-## 挑战
+加密后的数据列。
+
+### 查询辅助列
+
+用于查询的辅助列。
+对于一些安全级别更高的非幂等加密算法，提供不可逆的幂等列用于查询。
+
+### 明文列
+
+存储明文的列，用于在加密数据迁移过程中仍旧提供服务。
+在洗数结束后可以删除。
+
+## 对系统的影响
 
 在真实业务场景中，相关业务开发团队则往往需要针对公司安全部门需求，自行实行并维护一套加解密系统。
 而当加密场景发生改变时，自行维护的加密系统往往又面临着重构或修改风险。
 此外，对于已经上线的业务，在不修改业务逻辑和 SQL 的情况下，透明化、安全低风险地实现无缝进行加密改造也相对复杂。
 
-## 目标
+## 使用限制
+
+- 需自行处理数据库中原始的存量数据；
+- 加密字段无法支持查询不区分大小写功能；
+- 加密字段无法支持比较操作，如：大于、小于、ORDER BY、BETWEEN、LIKE 等；
+- 加密字段无法支持计算操作，如：AVG、SUM 以及计算表达式。
+
+## 原理介绍
+
+Apache ShardingSphere 通过对用户输入的 SQL 进行解析，并依据用户提供的加密规则对 SQL 进行改写，从而实现对原文数据进行加密，并将原文数据（可选）及密文数据同时存储到底层数据库。
+在用户查询数据时，它仅从数据库中取出密文数据，并对其解密，最终将解密后的原始数据返回给用户。
+Apache ShardingSphere 自动化 & 透明化了数据加密过程，让用户无需关注数据加密的实现细节，像使用普通数据那样使用加密数据。
+此外，无论是已在线业务进行加密改造，还是新上线业务使用加密功能，Apache ShardingSphere 都可以提供一套相对完善的解决方案。
+
+### 整体架构
+
+![1](https://shardingsphere.apache.org/document/current/img/encrypt/1.png)
+
+加密模块将用户发起的 SQL 进行拦截，并通过 SQL 语法解析器进行解析、理解 SQL 行为，再依据用户传入的加密规则，找出需要加密的字段和所使用的加解密算法对目标字段进行加解密处理后，再与底层数据库进行交互。
+Apache ShardingSphere 会将用户请求的明文进行加密后存储到底层数据库；并在用户查询时，将密文从数据库中取出进行解密后返回给终端用户。
+通过屏蔽对数据的加密处理，使用户无需感知解析 SQL、数据加密、数据解密的处理过程，就像在使用普通数据一样使用加密数据。
+
+### 加密规则
+
+在详解整套流程之前，我们需要先了解下加密规则与配置，这是认识整套流程的基础。
+加密配置主要分为四部分：数据源配置，加密算法配置，加密表配置以及查询属性配置，其详情如下图所示：
+
+![2](https://shardingsphere.apache.org/document/current/img/encrypt/2.png)
+
+**数据源配置**：指数据源配置。
+
+**加密器配置**：指使用什么加密算法进行加解密。目前 ShardingSphere 内置了三种加解密算法：AES，MD5 和 RC4。用户还可以通过实现 ShardingSphere 提供的接口，自行实现一套加解密算法。
+
+**加密表配置**：用于告诉 ShardingSphere 数据表里哪个列用于存储密文数据（cipherColumn）、哪个列用于存储明文数据（plainColumn）以及用户想使用哪个列进行 SQL 编写（logicColumn）。
+
+> 如何理解 `用户想使用哪个列进行 SQL 编写（logicColumn）`？
+> 
+> 我们可以从加密模块存在的意义来理解。加密模块最终目的是希望屏蔽底层对数据的加密处理，也就是说我们不希望用户知道数据是如何被加解密的、如何将明文数据存储到 plainColumn，将密文数据存储到 cipherColumn。
+> 换句话说，我们不希望用户知道 plainColumn 和 cipherColumn 的存在和使用。
+> 所以，我们需要给用户提供一个概念意义上的列，这个列可以脱离底层数据库的真实列，它可以是数据库表里的一个真实列，也可以不是，从而使得用户可以随意改变底层数据库的 plainColumn 和 cipherColumn 的列名。
+> 或者删除 plainColumn，选择永远不再存储明文，只存储密文。
+> 只要用户的 SQL 面向这个逻辑列进行编写，并在加密规则里给出 logicColumn 和 plainColumn、cipherColumn 之间正确的映射关系即可。
+为什么要这么做呢？答案在文章后面，即为了让已上线的业务能无缝、透明、安全地进行数据加密迁移。
+
+**查询属性的配置**：当底层数据库表里同时存储了明文数据、密文数据后，该属性开关用于决定是直接查询数据库表里的明文数据进行返回，还是查询密文数据通过 Apache ShardingSphere 解密后返回。该属性开关支持表级别和整个规则级别配置，表级别优先级最高。
+
+### 加密处理过程
+
+举例说明，假如数据库里有一张表叫做 `t_user`，这张表里实际有两个字段 `pwd_plain`，用于存放明文数据、`pwd_cipher`，用于存放密文数据，同时定义 logicColumn 为 `pwd`。
+那么，用户在编写 SQL 时应该面向 logicColumn 进行编写，即 `INSERT INTO t_user SET pwd = '123'`。
+Apache ShardingSphere 接收到该 SQL，通过用户提供的加密配置，发现 `pwd` 是 logicColumn，于是便对逻辑列及其对应的明文数据进行加密处理。
+**Apache ShardingSphere 将面向用户的逻辑列与面向底层数据库的明文列和密文列进行了列名以及数据的加密映射转换。**
+如下图所示：
+
+![3](https://shardingsphere.apache.org/document/current/img/encrypt/3.png)
+
+即依据用户提供的加密规则，将用户 SQL 与底层数据表结构割裂开来，使得用户的 SQL 编写不再依赖于真实的数据库表结构。
+而用户与底层数据库之间的衔接、映射、转换交由 Apache ShardingSphere 进行处理。
+下方图片展示了使用加密模块进行增删改查时，其中的处理流程和转换逻辑，如下图所示。
+
+![4](https://shardingsphere.apache.org/document/current/img/encrypt/4.png)
 
-**根据业界对加密的需求及业务改造痛点，提供了一套完整、安全、透明化、低改造成本的数据加密整合解决方案，是 Apache ShardingSphere 数据加密模块的主要设计目标。**
+## 相关参考
 
-**源码：https://github.com/apache/shardingsphere/tree/master/shardingsphere-features/shardingsphere-encrypt**
+- [数据加密配置](/cn/user-manual/shardingsphere-jdbc/yaml-config/rules/encrypt/)
+- [数据加密开发者指南](/cn/dev-manual/encryption/)
diff --git a/docs/document/content/features/encrypt/_index.en.md b/docs/document/content/features/encrypt/_index.en.md
index 906a239724c..3d263007644 100644
--- a/docs/document/content/features/encrypt/_index.en.md
+++ b/docs/document/content/features/encrypt/_index.en.md
@@ -5,32 +5,83 @@ weight = 9
 chapter = true
 +++
 
-## Background
+## Definition
 
-Security control has always been a crucial link of data governance, data encryption falls into this category. 
-For both Internet enterprises and traditional sectors, data security has always been a highly valued and sensitive topic. 
-Data encryption refers to transforming some sensitive information through encrypt rules to safely protect the private data. 
-Data involves client's security or business sensibility, 
-such as ID number, phone number, card number, client number and other personal information, requires data encryption according to relevant regulations.
+Data encryption refers to the modification of some sensitive information through encryption rules in order to offer reliable protection to sensitive private data. Data related to customer security or some sensitive commercial data, such as ID number, mobile phone number, card number, customer number, and other personal information, shall be encrypted according to the regulations of respective regulations.
 
-The demand for data encryption is generally divided into two situations in real business scenarios:
+## Related Concepts
 
-1. When the new business start to launch, and the security department stipulates that the sensitive information related to users, such as banks and mobile phone numbers, should be encrypted and stored in the database, and then decrypted when used. Because it is a brand new system, there is no inventory data cleaning problem, so the implementation is relatively simple.
+### Logic column
 
-2. For the service has been launched, and plaintext has been stored in the database before. The relevant department suddenly needs to encrypt the data from the on-line business. This scenario generally needs to deal with three issues as followings:
+It is used to calculate the encryption and decryption columns and it is the logical identifier of the column in SQL. Logical columns contain ciphertext columns (mandatory), query-helper columns (optional), and plaintext columns (optional).
 
-* How to encrypt the historical data, a.k.a.s data clean.
-* How to encrypt the newly added data and store it in the database without changing the business SQL and logic; then decrypt the taken out data when use it.
-* How to securely, seamlessly and transparently migrate plaintext and ciphertext data between business systems.
+### Cipher column
 
-## Challenges
+Encrypted data columns.
 
-In the real business scenario, the relevant business development team often needs to implement and maintain a set of encryption and decryption system according to the needs of the company's security department.
-When the encryption scenario changes, the encryption system often faces the risk of reconstruction or modification.
-In addition, for the online business system, it is relatively complex to realize seamless encryption transformation with transparency, security and low risk without modifying the business logic and SQL.
+### Query assistant column
 
-## Goal
+It is a helper column used for queries. For some non-idempotent encryption algorithms with higher security levels, irreversible idempotent columns are provided for queries.
 
-**Provides a security and transparent data encryption solution, which is the main design goal of Apache ShardingSphere data encryption module.**
+### Plain column
 
-**Source Codes: https://github.com/apache/shardingsphere/tree/master/shardingsphere-features/shardingsphere-encrypt**
+The column is used to store plaintext and provide services during the migration of encrypted data. It can be deleted after the data cleansing is complete.
+
+## Impact on the system
+
+In real business scenarios, service development teams need to implement and maintain a set of encryption and decryption systems based on the requirements of the security department. When the encryption scenario changes, the self-maintained encryption system often faces the risk of reconstruction or modification. Additionally, for services that have been launched, it is relatively complicated to achieve seamless encrypted transformation in a transparent and secure manner without modifying business logic and SQL.
+
+## Limitations
+
+- You need to process the original data on stocks in the database by yourself.
+- The case-insensitive queries are not supported for encrypted fields.
+- Comparison operations are not supported for encrypted fields, such as GREATER THAN, LESS THAN, ORDER BY, BETWEEN, LIKE.
+- Calculation operations are not supported for encrypted fields, such as AVG, SUM, and computation expressions.
+
+## How it works
+
+Apache ShardingSphere parses the SQL entered by users and rewrites the SQL according to the encryption rules provided by users, to encrypt the source data and store the source data (optional) and ciphertext data in the underlying database.
+When a user queries data, it only retrieves ciphertext data from the database, decrypts it, and finally returns the decrypted source data to the user. Apache ShardingSphere achieves a transparent and automatic data encryption process. Users can use encrypted data as normal data without paying attention to the implementation details of data encryption. 
+
+### Overall architecture
+
+![1](https://shardingsphere.apache.org/document/current/img/encrypt/1_en.png)
+
+The encrypted module intercepts the SQL initiated by the user and parses and understands the SQL behavior through the SQL grammar parser. Then it finds out the fields to be encrypted and the encryption and decryption algorithm according to the encryption rules introduced by the user and interacts with the underlying database.
+Apache ShardingSphere will encrypt the plaintext requested by users and store it in the underlying database. When the user queries, the ciphertext is extracted from the database, decrypted, and returned to the terminal user. By shielding the data encryption process, users do not need to operate the SQL parsing process, data encryption, and data decryption.
+
+### Encryption rules
+
+Before explaining the whole process, we need to understand the encryption rules and configuration. Encryption configuration is mainly divided into four parts: data source configuration, encryptor configuration, encryption table configuration and query attribute configuration, as shown in the figure below:
+
+![2](https://shardingsphere.apache.org/document/current/img/encrypt/2_en.png)
+
+**Data source configuration**: literally the configuration of the data source.
+
+**Encryptor configuration**: refers to the encryption algorithm used for encryption and decryption. Currently, ShardingSphere has three built-in encryption and decryption algorithms: AES, MD5 and RC4. Users can also implement a set of encryption and decryption algorithms by implementing the interfaces provided by ShardingSphere.
+
+**Encryption table configuration**: it is used to tell ShardingSphere which column in the data table is used to store ciphertext data (cipherColumn), which column is used to store plaintext data (plainColumn), and which column the user would like to use for SQL writing (logicColumn).
+
+> What does it mean by "which column the user would like to use for SQL writing (logicColumn)"?
+> 
+> We have to know first why the encrypted module exists. The goal of the encrypted module is to shield the underlying data encryption process, which means we don't want users to know how data is encrypted and decrypted, and how to store plaintext data into plainColumn and ciphertext data into cipherColumn. In other words, we don't want users to know there is a plainColumn and cipherColumn or how they are used. Therefore, we need to provide the user with a conceptual column that can be separated from the real column in the underlying database. It may or may not be a real column in the database table so that users can change the column names of plainColumn and cipherColumn of the underlying database at will. Or we can delete plainColumn and never store plaintext, only ciphertext. The only thing we have to ensure is that the user's SQL is written towards the logical column, and the correct mapping relation between logicColumn, plainColumn and cipherColumn can be seen in the encryption rules.
+
+**Query attribute configuration**: if both plaintext and ciphertext data are stored in the underlying database table, this attribute can be used to determine whether to query the plaintext data in the database table and return it directly, or query the ciphertext data and return it after decryption through Apache ShardingSphere. This attribute can be configured at the table level and the entire rule level. The table-level has the highest priority.
+
+### Encryption process
+
+For example, if there is a table named `t_user` in the database, and there actually are two fields in the table: `pwd_plain` for storing plaintext data and `pwd_cipher` for storing ciphertext data, and logicColumn is defined as `pwd`, then users should write SQL for logicColumn, that is `INSERT INTO t_user SET pwd = '123'`. Apache ShardingSphere receives the SQL and finds that the `pwd` is the logicColumn based on the encryption configuration provided by the user. Therefore, it encrypts the logical column and its corresponding plaintext data.
+**Apache ShardingSphere transforms the column names and data encryption mapping between the logical columns facing users and the plaintext and ciphertext columns facing the underlying database**. As shown in the figure below:
+
+![3](https://shardingsphere.apache.org/document/current/img/encrypt/3_en.png)
+
+The user's SQL is separated from the underlying data table structure according to the encryption rules provided by the user so that the user's SQL writing does not depend on the real database table structure.
+The connection, mapping, and transformation between the user and the underlying database are handled by Apache ShardingSphere.
+The picture below shows the processing flow and conversion logic when the encryption module is used to add, delete, change and check, as shown in the figure below.
+
+![4](https://shardingsphere.apache.org/document/current/img/encrypt/4_en.png)
+
+## Related References
+
+- [Data encryption configuration](/en/user-manual/shardingsphere-jdbc/yaml-config/rules/encrypt/)
+- [Developer guide of data encryption](/en/dev-manual/encryption/)
diff --git a/docs/document/content/features/encrypt/concept.cn.md b/docs/document/content/features/encrypt/concept.cn.md
deleted file mode 100644
index a606220d737..00000000000
--- a/docs/document/content/features/encrypt/concept.cn.md
+++ /dev/null
@@ -1,23 +0,0 @@
-+++
-title = "核心概念"
-weight = 1
-+++
-
-## 逻辑列
-
-用于计算加解密列的逻辑名称，是 SQL 中列的逻辑标识。
-逻辑列包含密文列（必须）、查询辅助列（可选）和明文列（可选）。
-
-## 密文列
-
-加密后的数据列。
-
-## 查询辅助列
-
-用于查询的辅助列。
-对于一些安全级别更高的非幂等加密算法，提供不可逆的幂等列用于查询。
-
-## 明文列
-
-存储明文的列，用于在加密数据迁移过程中仍旧提供服务。
-在洗数结束后可以删除。
diff --git a/docs/document/content/features/encrypt/concept.en.md b/docs/document/content/features/encrypt/concept.en.md
deleted file mode 100644
index 3323dd638ca..00000000000
--- a/docs/document/content/features/encrypt/concept.en.md
+++ /dev/null
@@ -1,23 +0,0 @@
-+++
-title = "Core Concept"
-weight = 1
-+++
-
-## Logic Column
-
-Column name used to encryption, it is the logical column identification in SQL.
-It includes cipher column(required), query assistant column(optional) and plain column(optional).
-
-## Cipher Column
-
-Encrypted data column.
-
-## Query Assistant Column
-
-Column used to assistant for query.
-For non-idempotent encryption algorithms with higher security level, irreversible idempotent columns provided for query.
-
-## Plain Column
-
-Column used to persist plain column, for service provided during data encrypting.
-Should remove them after data clean.
diff --git a/docs/document/content/features/encrypt/use-norms.cn.md b/docs/document/content/features/encrypt/use-norms.cn.md
deleted file mode 100644
index 9ca42d436ae..00000000000
--- a/docs/document/content/features/encrypt/use-norms.cn.md
+++ /dev/null
@@ -1,16 +0,0 @@
-+++
-title = "使用规范"
-weight = 2
-+++
-
-## 支持项
-
-* 对数据库表中某个或多个列进行加解密；
-* 兼容所有常用 SQL。
-
-## 不支持项
-
-* 需自行处理数据库中原始的存量数据；
-* 加密字段无法支持查询不区分大小写功能；
-* 加密字段无法支持比较操作，如：大于、小于、ORDER BY、BETWEEN、LIKE 等；
-* 加密字段无法支持计算操作，如：AVG、SUM 以及计算表达式。
diff --git a/docs/document/content/features/encrypt/use-norms.en.md b/docs/document/content/features/encrypt/use-norms.en.md
deleted file mode 100644
index b6580d42343..00000000000
--- a/docs/document/content/features/encrypt/use-norms.en.md
+++ /dev/null
@@ -1,16 +0,0 @@
-+++
-title = "Use Norms"
-weight = 2
-+++
-
-## Supported
-
-* Encrypt/decrypt one or more columns in the database table;
-* Compatible with all regular SQL.
-
-## Unsupported
-
-* Need to process original inventory data before encryption;
-* Encrypted fields cannot support case insensitive queries;
-* The value of encryption columns cannot support comparison, such as: >, <, ORDER BY, BETWEEN, LIKE, etc;
-* The value of encryption columns cannot support calculation, such as AVG, SUM, and calculation expressions.
